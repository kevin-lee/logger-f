[{"title":"Get LoggerF","type":0,"sectionRef":"#","url":"docs/cats-effect/getting-started","content":"","keywords":""},{"title":"Get LoggerF for Cats Effect​","type":1,"pageTitle":"Get LoggerF","url":"docs/cats-effect/getting-started#get-loggerf-for-cats-effect","content":"In build.sbt, Cats Effect 3Cats Effect 2 &quot;io.kevinlee&quot; %% &quot;logger-f-cats-effect&quot; % &quot;1.20.0&quot; Copy "},{"title":"With SLF4J​","type":1,"pageTitle":"Get LoggerF","url":"docs/cats-effect/getting-started#with-slf4j","content":"To use logger-f with SLF4J, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-slf4j&quot; % &quot;1.20.0&quot; Copy "},{"title":"With Log4j​","type":1,"pageTitle":"Get LoggerF","url":"docs/cats-effect/getting-started#with-log4j","content":"To use logger-f with Log4j, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-log4j&quot; % &quot;1.20.0&quot; Copy "},{"title":"With Log4s​","type":1,"pageTitle":"Get LoggerF","url":"docs/cats-effect/getting-started#with-log4s","content":"To use logger-f with Log4s, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-log4s&quot; % &quot;1.20.0&quot; Copy "},{"title":"With sbt Logging Util​","type":1,"pageTitle":"Get LoggerF","url":"docs/cats-effect/getting-started#with-sbt-logging-util","content":"You probably need logger-f for sbt plugin development. &quot;io.kevinlee&quot; %% &quot;logger-f-sbt-logging&quot; % &quot;1.20.0&quot; Copy "},{"title":"Log​","type":1,"pageTitle":"Get LoggerF","url":"docs/cats-effect/getting-started#log","content":""},{"title":"Log - Cats","type":0,"sectionRef":"#","url":"docs/cats-effect/log","content":"","keywords":""},{"title":"Log - Cats (WIP)​","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log---cats-wip","content":"Log is a typeclass to log F[A], F[Option[A]], F[Either[A, B]], OptionT[F, A] and EitherT[F, A, B]. It requires Fx from Effectie and Monad from Cats. "},{"title":"Log F[A]​","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-fa","content":"Log[F].log(F[A])(A =&gt; String) Copy A given F[A], you can simply log A with log. import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ def hello[F[_]: Functor: Fx: Log](name: String): F[Unit] = log(pureOf(s&quot;Hello $name&quot;))(debug).map(println(_)) object MyApp extends IOApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp&quot;) def run(args: List[String]): IO[ExitCode] = for { _ &lt;- hello[IO](&quot;World&quot;) _ &lt;- hello[IO](&quot;Kevin&quot;) } yield ExitCode.Success } Copy 23:34:25.021 [ioapp-compute-1] DEBUG MyApp - Hello World Hello World 23:34:25.022 [ioapp-compute-1] DEBUG MyApp - Hello Kevin Hello Kevin Copy "},{"title":"Example​","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#example","content":"trait Named[A] { def name(a: A): String } object Named { def apply[A: Named]: Named[A] = implicitly[Named[A]] } final case class GivenName(givenName: String) extends AnyVal final case class Surname(surname: String) extends AnyVal final case class Person(givenName: GivenName, surname: Surname) object Person { implicit val namedPerson: Named[Person] = person =&gt; s&quot;${person.givenName.givenName} ${person.surname.surname}&quot; } import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Fx import effectie.cats.ConsoleEffect import effectie.cats.Effectful._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ trait Greeting[F[_]] { def greet[A: Named](a: A): F[String] } object Greeting { def apply[F[_] : Greeting]: Greeting[F] = implicitly[Greeting[F]] implicit def hello[F[_]: Fx: Monad: Log]: Greeting[F] = new Greeting[F] { def greet[A: Named](a: A): F[String] = for { name &lt;- log(effectOf(Named[A].name(a)))(x =&gt; info(s&quot;The name is $x&quot;)) greeting &lt;- pureOf(s&quot;Hello $name&quot;) } yield greeting } } object MyApp extends IOApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp&quot;) def run(args: List[String]): IO[ExitCode] = for { greetingMessage &lt;- Greeting[IO].greet(Person(GivenName(&quot;Kevin&quot;), Surname(&quot;Lee&quot;))) _ &lt;- ConsoleEffect[IO].putStrLn(greetingMessage) } yield ExitCode.Success } Copy 21:02:15.323 [ioapp-compute-0] INFO MyApp - The name is Kevin Lee Hello Kevin Lee Copy "},{"title":"Log F[Option[A]]​","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-foptiona","content":"Log[Option[F]].log( F[Option[A]] )( ifEmpty: =&gt; LogMessage with MaybeIgnorable, toLeveledMessage: A =&gt; LogMessage with MaybeIgnorable, ) Copy A given F[A], you can simply log A with log. import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ def hello[F[_]: Functor: Fx: Log](name: Option[String]): F[Option[Unit]] = { log(pureOf(name))(warn(&quot;No name given&quot;), a =&gt; info(s&quot;Name: $a&quot;)) .map(maybeName =&gt; maybeName.map(name =&gt; println(s&quot;Hello $name&quot;))) } object MyApp extends IOApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp&quot;) def run(args: List[String]): IO[ExitCode] = for { _ &lt;- hello[IO](none) _ &lt;- hello[IO](&quot;Kevin&quot;.some) } yield ExitCode.Success } Copy 23:42:22.584 [ioapp-compute-1] WARN MyApp - No name given 23:42:22.585 [ioapp-compute-1] INFO MyApp - Name: Kevin Hello Kevin Copy "},{"title":"Log F[Either[A, B]]​","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-feithera-b","content":""},{"title":"Log OptionT[F, A]​","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-optiontf-a","content":""},{"title":"Log EitherT[F, A, B]​","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-eithertf-a-b","content":""},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/","content":"","keywords":""},{"title":" LoggerF - Logger for F[_]​","type":1,"pageTitle":"Getting Started","url":"docs/#-loggerf---logger-for-f_","content":"LoggerF is a tool for logging tagless final with an effect library. LoggerF requires Effectie to construct F[_]. All the example code in this doc site uses Effectie so if you're not familiar with it, please check out Effectie website. Why LoggerF? Why not just log with map or flatMap? Please read &quot;Why?&quot; section. "},{"title":"Getting Started​","type":1,"pageTitle":"Getting Started","url":"docs/#getting-started","content":""},{"title":"Get LoggerF For Cats Effect​","type":1,"pageTitle":"Getting Started","url":"docs/#get-loggerf-for-cats-effect","content":"With SLF4J​ In build.sbt, Cats Effect 3Cats Effect 2 libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-cats-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-slf4j&quot; % &quot;1.20.0&quot; ) Copy With Log4j​ Cats Effect 3Cats Effect 2 libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-cats-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-log4j&quot; % &quot;1.20.0&quot; ) Copy With Log4s​ Cats Effect 3Cats Effect 2 libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-cats-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-log4s&quot; % &quot;1.20.0&quot; ) Copy With sbt Logging Util​ You probably need logger-f for sbt plugin development. Cats Effect 3Cats Effect 2 libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-cats-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-sbt-logging&quot; % &quot;1.20.0&quot; ) Copy "},{"title":"Get LoggerF For Monix​","type":1,"pageTitle":"Getting Started","url":"docs/#get-loggerf-for-monix","content":"With SLF4J​ In build.sbt, libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-monix&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-slf4j&quot; % &quot;1.20.0&quot; ) Copy With Log4j​ libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-monix&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-log4j&quot; % &quot;1.20.0&quot; ) Copy With Log4s​ libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-monix&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-log4s&quot; % &quot;1.20.0&quot; ) Copy With sbt Logging Util​ You probably need logger-f for sbt plugin development. libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-monix&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-sbt-logging&quot; % &quot;1.20.0&quot; ) Copy "},{"title":"Get LoggerF For Scalaz Effect​","type":1,"pageTitle":"Getting Started","url":"docs/#get-loggerf-for-scalaz-effect","content":"With SLF4J​ In build.sbt, libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-scalaz-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-slf4j&quot; % &quot;1.20.0&quot; ) Copy With Log4j​ In build.sbt, libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-scalaz-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-log4j&quot; % &quot;1.20.0&quot; ) Copy With Log4s​ In build.sbt, libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-scalaz-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-log4s&quot; % &quot;1.20.0&quot; ) Copy With sbt Logging Util​ In build.sbt, libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-scalaz-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-sbt-logging&quot; % &quot;1.20.0&quot; ) Copy "},{"title":"Why​","type":1,"pageTitle":"Getting Started","url":"docs/#why","content":"If you code tagless final and use some effect library like Cats Effect or Monix or Scalaz Effect, you may have inconvenience in logging. What inconvenience? I can just log with flatMap like. for { a &lt;- foo(n) // F[A] _ &lt;- effectOf(logger.debug(s&quot;blah blah $a&quot;)) b &lt;- bar(a) // F[A] } yield b Copy That's true but what happens if you want to use Option or Either? If you use them with tagless final, you may get the result you want. e.g.) import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ def foo[F[_] : Fx : Monad](n: Int): F[Option[Int]] = for { a &lt;- effectOf(n.some) b &lt;- effectOf(none[Int]) c &lt;- effectOf(123.some) } yield c foo[IO](1).unsafeRunSync() // You expect None here!!! // res1: Option[Int] = Some(value = 123) Copy You expect None for the result due to effectOf(none[Int]) yet you get Some(123) instead. That's because b is Option[Int] not Int. The same issue exists for F[Either[A, B]] as well. So you need to use OptionT for F[Option[A]] and EitherT for F[Either[A, B]]. Let's write it again with OptionT. import cats._ import cats.data._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ def foo[F[_] : Fx : Monad](n: Int): F[Option[Int]] = (for { a &lt;- OptionT(effectOf(n.some)) b &lt;- OptionT(effectOf(none[Int])) c &lt;- OptionT(effectOf(123.some)) } yield c).value foo[IO](1).unsafeRunSync() // You expect None here. // res3: Option[Int] = None Copy The problem's gone! Now each flatMap handles only Some case and that's what you want. However, because of that, it's hard to log None case. LoggerF can solve this issue for you. import cats._ import cats.data._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ // or Slf4JLogger.slf4JLogger[MyClass] implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyLogger&quot;) // canLog: CanLog = loggerf.logger.Slf4JLogger@337ce32f def foo[F[_] : Fx : Monad : Log](n: Int): F[Option[Int]] = (for { a &lt;- log(OptionT(effectOf(n.some)))( ifEmpty = error(&quot;a is empty&quot;), a =&gt; debug(s&quot;a is $a&quot;) ) b &lt;- log(OptionT(effectOf(none[Int])))( error(&quot;b is empty&quot;), b =&gt; debug(s&quot;b is $b&quot;) ) c &lt;- log(OptionT(effectOf(123.some)))( warn(&quot;c is empty&quot;), c =&gt; debug(s&quot;c is $c&quot;) ) } yield c).value foo[IO](1).unsafeRunSync() // You expect None here. // res5: Option[Int] = None Copy With logs like 00:17:33.983 [main] DEBUG MyLogger - a is 1 00:17:33.995 [main] ERROR MyLogger - b is empty Copy  Another example with EitherT, import cats._ import cats.data._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ // or Slf4JLogger.slf4JLogger[MyClass] implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyLogger&quot;) // canLog: CanLog = loggerf.logger.Slf4JLogger@3bcdffe0 def foo[F[_] : Fx : Monad : Log](n: Int): F[Either[String, Int]] = (for { a &lt;- log(EitherT(effectOf(n.asRight[String])))( err =&gt; error(s&quot;Error: $err&quot;), a =&gt; debug(s&quot;a is $a&quot;) ) b &lt;- log(EitherT(effectOf(&quot;Some Error&quot;.asLeft[Int])))( err =&gt; error(s&quot;Error: $err&quot;), b =&gt; debug(s&quot;b is $b&quot;) ) c &lt;- log(EitherT(effectOf(123.asRight[String])))( err =&gt; warn(s&quot;Error: $err&quot;), c =&gt; debug(s&quot;c is $c&quot;) ) } yield c).value foo[IO](1).unsafeRunSync() // You expect Left(&quot;Some Error&quot;) here. // res7: Either[String, Int] = Left(value = &quot;Some Error&quot;) Copy With logs like 00:40:48.663 [main] DEBUG MyLogger - a is 1 00:40:48.667 [main] ERROR MyLogger - Error: Some Error Copy "},{"title":"Usage​","type":1,"pageTitle":"Getting Started","url":"docs/#usage","content":"Pleae check out LoggerF for Cats EffectLoggerF for MonixLoggerF for Scalaz Effect "},{"title":"Get LoggerF","type":0,"sectionRef":"#","url":"docs/monix/getting-started","content":"","keywords":""},{"title":"Get LoggerF for Monix​","type":1,"pageTitle":"Get LoggerF","url":"docs/monix/getting-started#get-loggerf-for-monix","content":"In build.sbt, &quot;io.kevinlee&quot; %% &quot;logger-f-monix&quot; % &quot;1.20.0&quot; Copy "},{"title":"With SLF4J​","type":1,"pageTitle":"Get LoggerF","url":"docs/monix/getting-started#with-slf4j","content":"To use logger-f with SLF4J, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-slf4j&quot; % &quot;1.20.0&quot; Copy "},{"title":"With Log4j​","type":1,"pageTitle":"Get LoggerF","url":"docs/monix/getting-started#with-log4j","content":"To use logger-f with Log4j, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-log4j&quot; % &quot;1.20.0&quot; Copy "},{"title":"With Log4s​","type":1,"pageTitle":"Get LoggerF","url":"docs/monix/getting-started#with-log4s","content":"To use logger-f with Log4s, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-log4s&quot; % &quot;1.20.0&quot; Copy "},{"title":"With sbt Logging Util​","type":1,"pageTitle":"Get LoggerF","url":"docs/monix/getting-started#with-sbt-logging-util","content":"You probably need logger-f for sbt plugin development. &quot;io.kevinlee&quot; %% &quot;logger-f-sbt-logging&quot; % &quot;1.20.0&quot; Copy "},{"title":"Log​","type":1,"pageTitle":"Get LoggerF","url":"docs/monix/getting-started#log","content":""},{"title":"Log - Monix","type":0,"sectionRef":"#","url":"docs/monix/log","content":"","keywords":""},{"title":"Log - Monix (WIP)​","type":1,"pageTitle":"Log - Monix","url":"docs/monix/log#log---monix-wip","content":"Log is a typeclass to log F[A], F[Option[A]], F[Either[A, B]], OptionT[F, A] and EitherT[F, A, B]. It requires Fx from Effectie and Monad from Cats. "},{"title":"Log F[A]​","type":1,"pageTitle":"Log - Monix","url":"docs/monix/log#log-fa","content":"Log[F].log(F[A])(A =&gt; String) Copy "},{"title":"Example​","type":1,"pageTitle":"Log - Monix","url":"docs/monix/log#example","content":"trait Named[A] { def name(a: A): String } object Named { def apply[A: Named]: Named[A] = implicitly[Named[A]] } final case class GivenName(givenName: String) extends AnyVal final case class Surname(surname: String) extends AnyVal final case class Person(givenName: GivenName, surname: Surname) object Person { implicit val namedPerson: Named[Person] = person =&gt; s&quot;${person.givenName.givenName} ${person.surname.surname}&quot; } import cats._ import cats.syntax.all._ import cats.effect.ExitCode import effectie.monix.{ConsoleEffect, Fx} import effectie.monix.Effectful._ import loggerf.logger._ import loggerf.monix._ import loggerf.syntax._ import monix.eval.Task import monix.eval.TaskApp trait Greeting[F[_]] { def greet[A: Named](a: A): F[String] } object Greeting { def apply[F[_]: Greeting]: Greeting[F] = implicitly[Greeting[F]] implicit def hello[F[_]: Fx: Monad: Log]: Greeting[F] = new Greeting[F] { def greet[A: Named](a: A): F[String] = for { name &lt;- log(effectOf(Named[A].name(a)))(x =&gt; info(s&quot;The name is $x&quot;)) greeting &lt;- pureOf(s&quot;Hello $name&quot;) } yield greeting } } object TaskMainApp extends TaskApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp&quot;) def run(args: List[String]): Task[ExitCode] = for { greetingMessage &lt;- Greeting[Task].greet( Person(GivenName(&quot;Kevin&quot;), Surname(&quot;Lee&quot;)) ) _ &lt;- ConsoleEffect[Task].putStrLn(greetingMessage) } yield ExitCode.Success } Copy 19:57:04.076 [scala-execution-context-global-21] INFO MyApp - The name is Kevin Lee Hello Kevin Lee Copy "},{"title":"Log F[Option[A]]​","type":1,"pageTitle":"Log - Monix","url":"docs/monix/log#log-foptiona","content":""},{"title":"Log OptionT[F, A]​","type":1,"pageTitle":"Log - Monix","url":"docs/monix/log#log-optiontf-a","content":""},{"title":"Log F[Either[A, B]]​","type":1,"pageTitle":"Log - Monix","url":"docs/monix/log#log-feithera-b","content":""},{"title":"Log EitherT[F, A, B]​","type":1,"pageTitle":"Log - Monix","url":"docs/monix/log#log-eithertf-a-b","content":""},{"title":"Get LoggerF","type":0,"sectionRef":"#","url":"docs/scalaz-effect/getting-started","content":"","keywords":""},{"title":"Get LoggerF For Scalaz Effect​","type":1,"pageTitle":"Get LoggerF","url":"docs/scalaz-effect/getting-started#get-loggerf-for-scalaz-effect","content":"In build.sbt, &quot;io.kevinlee&quot; %% &quot;logger-f-scalaz-effect&quot; % &quot;1.20.0&quot; Copy "},{"title":"With SLF4J​","type":1,"pageTitle":"Get LoggerF","url":"docs/scalaz-effect/getting-started#with-slf4j","content":"To use logger-f with SLF4J, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-slf4j&quot; % &quot;1.20.0&quot; Copy "},{"title":"With Log4j​","type":1,"pageTitle":"Get LoggerF","url":"docs/scalaz-effect/getting-started#with-log4j","content":"To use logger-f with Log4j, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-log4j&quot; % &quot;1.20.0&quot; Copy "},{"title":"With Log4s​","type":1,"pageTitle":"Get LoggerF","url":"docs/scalaz-effect/getting-started#with-log4s","content":"To use logger-f with Log4s, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-log4s&quot; % &quot;1.20.0&quot; Copy "},{"title":"With sbt Logging Util​","type":1,"pageTitle":"Get LoggerF","url":"docs/scalaz-effect/getting-started#with-sbt-logging-util","content":"You probably need logger-f for sbt plugin development. &quot;io.kevinlee&quot; %% &quot;logger-f-sbt-logging&quot; % &quot;1.20.0&quot; Copy "},{"title":"Log​","type":1,"pageTitle":"Get LoggerF","url":"docs/scalaz-effect/getting-started#log","content":""},{"title":"Log - Scalaz","type":0,"sectionRef":"#","url":"docs/scalaz-effect/log","content":"","keywords":""},{"title":"Log - Scalaz (WIP)​","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log---scalaz-wip","content":"Log is a typeclass to log F[A], F[Option[A]], F[A \\/ B], OptionT[F, A] and EitherT[F, A, B]. It requires Fx from Effectie and Monad from Scalaz. "},{"title":"Log F[A]​","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-fa","content":"Log[F].log(F[A])(A =&gt; String) Copy "},{"title":"Example​","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#example","content":"trait Named[A] { def name(a: A): String } object Named { def apply[A: Named]: Named[A] = implicitly[Named[A]] } final case class GivenName(givenName: String) extends AnyVal final case class Surname(surname: String) extends AnyVal final case class Person(givenName: GivenName, surname: Surname) object Person { implicit val namedPerson: Named[Person] = person =&gt; s&quot;${person.givenName.givenName} ${person.surname.surname}&quot; } import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz.Fx import effectie.scalaz.ConsoleEffect import effectie.scalaz.Effectful._ import loggerf.logger._ import loggerf.scalaz._ import loggerf.syntax._ trait Greeting[F[_]] { def greet[A: Named](a: A): F[String] } object Greeting { def apply[F[_] : Greeting]: Greeting[F] = implicitly[Greeting[F]] implicit def hello[F[_]: Fx: Monad: Log]: Greeting[F] = new Greeting[F] { def greet[A: Named](a: A): F[String] = for { name &lt;- log(effectOf(Named[A].name(a)))(x =&gt; info(s&quot;The name is $x&quot;)) greeting &lt;- pureOf(s&quot;Hello $name&quot;) } yield greeting } } object MyApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp&quot;) def run(args: List[String]): IO[Unit] = for { greetingMessage &lt;- Greeting[IO].greet(Person(GivenName(&quot;Kevin&quot;), Surname(&quot;Lee&quot;))) _ &lt;- ConsoleEffect[IO].putStrLn(greetingMessage) } yield () def main(args: Array[String]): Unit = run(args.toList).unsafePerformIO() } Copy 21:02:15.323 [ioapp-compute-0] INFO MyApp - The name is Kevin Lee Hello Kevin Lee Copy "},{"title":"Log F[Option[A]]​","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-foptiona","content":""},{"title":"Log OptionT[F, A]​","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-optiontf-a","content":""},{"title":"Log F[A \\/ B]​","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-fa--b","content":""},{"title":"Log EitherT[F, A, B]​","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-eithertf-a-b","content":""}]