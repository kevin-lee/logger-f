[{"title":"Get LoggerF","type":0,"sectionRef":"#","url":"/docs/v1/docs/cats-effect/getting-started","content":"","keywords":""},{"title":"Get LoggerF for Cats Effect​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/cats-effect/getting-started#get-loggerf-for-cats-effect","content":"In build.sbt, Cats Effect 3Cats Effect 2 &quot;io.kevinlee&quot; %% &quot;logger-f-cats-effect&quot; % &quot;1.20.0&quot;  "},{"title":"With SLF4J​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/cats-effect/getting-started#with-slf4j","content":"To use logger-f with SLF4J, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-slf4j&quot; % &quot;1.20.0&quot;  "},{"title":"With Log4j​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/cats-effect/getting-started#with-log4j","content":"To use logger-f with Log4j, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-log4j&quot; % &quot;1.20.0&quot;  "},{"title":"With Log4s​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/cats-effect/getting-started#with-log4s","content":"To use logger-f with Log4s, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-log4s&quot; % &quot;1.20.0&quot;  "},{"title":"With sbt Logging Util​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/cats-effect/getting-started#with-sbt-logging-util","content":"You probably need logger-f for sbt plugin development. &quot;io.kevinlee&quot; %% &quot;logger-f-sbt-logging&quot; % &quot;1.20.0&quot;  "},{"title":"Log​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/cats-effect/getting-started#log","content":""},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/v1/","content":"","keywords":""},{"title":" LoggerF - Logger for F[_]​","type":1,"pageTitle":"Getting Started","url":"/docs/v1/#-loggerf---logger-for-f_","content":"LoggerF is a tool for logging tagless final with an effect library. LoggerF requires Effectie to construct F[_]. All the example code in this doc site uses Effectie so if you're not familiar with it, please check out Effectie website. Why LoggerF? Why not just log with map or flatMap? Please read &quot;Why?&quot; section. "},{"title":"Getting Started​","type":1,"pageTitle":"Getting Started","url":"/docs/v1/#getting-started","content":""},{"title":"Get LoggerF For Cats Effect​","type":1,"pageTitle":"Getting Started","url":"/docs/v1/#get-loggerf-for-cats-effect","content":"With SLF4J​ In build.sbt, Cats Effect 3Cats Effect 2 libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-cats-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-slf4j&quot; % &quot;1.20.0&quot; )  With Log4j​ Cats Effect 3Cats Effect 2 libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-cats-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-log4j&quot; % &quot;1.20.0&quot; )  With Log4s​ Cats Effect 3Cats Effect 2 libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-cats-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-log4s&quot; % &quot;1.20.0&quot; )  With sbt Logging Util​ You probably need logger-f for sbt plugin development. Cats Effect 3Cats Effect 2 libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-cats-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-sbt-logging&quot; % &quot;1.20.0&quot; )  "},{"title":"Get LoggerF For Monix​","type":1,"pageTitle":"Getting Started","url":"/docs/v1/#get-loggerf-for-monix","content":"With SLF4J​ In build.sbt, libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-monix&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-slf4j&quot; % &quot;1.20.0&quot; )  With Log4j​ libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-monix&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-log4j&quot; % &quot;1.20.0&quot; )  With Log4s​ libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-monix&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-log4s&quot; % &quot;1.20.0&quot; )  With sbt Logging Util​ You probably need logger-f for sbt plugin development. libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-monix&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-sbt-logging&quot; % &quot;1.20.0&quot; )  "},{"title":"Get LoggerF For Scalaz Effect​","type":1,"pageTitle":"Getting Started","url":"/docs/v1/#get-loggerf-for-scalaz-effect","content":"With SLF4J​ In build.sbt, libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-scalaz-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-slf4j&quot; % &quot;1.20.0&quot; )  With Log4j​ In build.sbt, libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-scalaz-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-log4j&quot; % &quot;1.20.0&quot; )  With Log4s​ In build.sbt, libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-scalaz-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-log4s&quot; % &quot;1.20.0&quot; )  With sbt Logging Util​ In build.sbt, libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-scalaz-effect&quot; % &quot;1.20.0&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-sbt-logging&quot; % &quot;1.20.0&quot; )  "},{"title":"Why​","type":1,"pageTitle":"Getting Started","url":"/docs/v1/#why","content":"If you code tagless final and use some effect library like Cats Effect or Monix or Scalaz Effect, you may have inconvenience in logging. What inconvenience? I can just log with flatMap like. for { a &lt;- foo(n) // F[A] _ &lt;- effectOf(logger.debug(s&quot;blah blah $a&quot;)) b &lt;- bar(a) // F[A] } yield b  That's true but what happens if you want to use Option or Either? If you use them with tagless final, you may not get the result you want. e.g.) import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ def foo[F[_] : Fx : Monad](n: Int): F[Option[Int]] = for { a &lt;- effectOf(n.some) b &lt;- effectOf(none[Int]) c &lt;- effectOf(123.some) } yield c foo[IO](1).unsafeRunSync() // You expect None here!!! // res1: Option[Int] = Some(value = 123)  You expect None for the result due to effectOf(none[Int]) yet you get Some(123) instead. That's because b is from F[Option[Int]] not from Option[Int]. The same issue exists for F[Either[A, B]] as well. So you need to use OptionT for F[Option[A]] and EitherT for F[Either[A, B]]. Let's write it again with OptionT. import cats._ import cats.data._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ def foo[F[_] : Fx : Monad](n: Int): F[Option[Int]] = (for { a &lt;- OptionT(effectOf(n.some)) b &lt;- OptionT(effectOf(none[Int])) c &lt;- OptionT(effectOf(123.some)) } yield c).value foo[IO](1).unsafeRunSync() // You expect None here. // res3: Option[Int] = None  The problem's gone! Now each flatMap handles only Some case and that's what you want. However, because of that, it's hard to log None case. LoggerF can solve this issue for you. import cats._ import cats.data._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ // or Slf4JLogger.slf4JLogger[MyClass] implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyLogger&quot;) // canLog: CanLog = loggerf.logger.Slf4JLogger@351f4ef4 def foo[F[_] : Fx : Monad : Log](n: Int): F[Option[Int]] = (for { a &lt;- log(OptionT(effectOf(n.some)))( ifEmpty = error(&quot;a is empty&quot;), a =&gt; debug(s&quot;a is $a&quot;) ) b &lt;- log(OptionT(effectOf(none[Int])))( error(&quot;b is empty&quot;), b =&gt; debug(s&quot;b is $b&quot;) ) c &lt;- log(OptionT(effectOf(123.some)))( warn(&quot;c is empty&quot;), c =&gt; debug(s&quot;c is $c&quot;) ) } yield c).value foo[IO](1).unsafeRunSync() // You expect None here. // res5: Option[Int] = None  With logs like 00:17:33.983 [main] DEBUG MyLogger - a is 1 00:17:33.995 [main] ERROR MyLogger - b is empty   Another example with EitherT, import cats._ import cats.data._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ // or Slf4JLogger.slf4JLogger[MyClass] implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyLogger&quot;) // canLog: CanLog = loggerf.logger.Slf4JLogger@6736691a def foo[F[_] : Fx : Monad : Log](n: Int): F[Either[String, Int]] = (for { a &lt;- log(EitherT(effectOf(n.asRight[String])))( err =&gt; error(s&quot;Error: $err&quot;), a =&gt; debug(s&quot;a is $a&quot;) ) b &lt;- log(EitherT(effectOf(&quot;Some Error&quot;.asLeft[Int])))( err =&gt; error(s&quot;Error: $err&quot;), b =&gt; debug(s&quot;b is $b&quot;) ) c &lt;- log(EitherT(effectOf(123.asRight[String])))( err =&gt; warn(s&quot;Error: $err&quot;), c =&gt; debug(s&quot;c is $c&quot;) ) } yield c).value foo[IO](1).unsafeRunSync() // You expect Left(&quot;Some Error&quot;) here. // res7: Either[String, Int] = Left(value = &quot;Some Error&quot;)  With logs like 00:40:48.663 [main] DEBUG MyLogger - a is 1 00:40:48.667 [main] ERROR MyLogger - Error: Some Error  "},{"title":"Usage​","type":1,"pageTitle":"Getting Started","url":"/docs/v1/#usage","content":"Pleae check out LoggerF for Cats EffectLoggerF for MonixLoggerF for Scalaz Effect "},{"title":"Get LoggerF","type":0,"sectionRef":"#","url":"/docs/v1/docs/monix/getting-started","content":"","keywords":""},{"title":"Get LoggerF for Monix​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/monix/getting-started#get-loggerf-for-monix","content":"In build.sbt, &quot;io.kevinlee&quot; %% &quot;logger-f-monix&quot; % &quot;1.20.0&quot;  "},{"title":"With SLF4J​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/monix/getting-started#with-slf4j","content":"To use logger-f with SLF4J, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-slf4j&quot; % &quot;1.20.0&quot;  "},{"title":"With Log4j​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/monix/getting-started#with-log4j","content":"To use logger-f with Log4j, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-log4j&quot; % &quot;1.20.0&quot;  "},{"title":"With Log4s​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/monix/getting-started#with-log4s","content":"To use logger-f with Log4s, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-log4s&quot; % &quot;1.20.0&quot;  "},{"title":"With sbt Logging Util​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/monix/getting-started#with-sbt-logging-util","content":"You probably need logger-f for sbt plugin development. &quot;io.kevinlee&quot; %% &quot;logger-f-sbt-logging&quot; % &quot;1.20.0&quot;  "},{"title":"Log​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/monix/getting-started#log","content":""},{"title":"Log - Cats","type":0,"sectionRef":"#","url":"/docs/v1/docs/cats-effect/log","content":"","keywords":""},{"title":"Log - Cats (WIP)​","type":1,"pageTitle":"Log - Cats","url":"/docs/v1/docs/cats-effect/log#log---cats-wip","content":"Log is a typeclass to log F[A], F[Option[A]], F[Either[A, B]], OptionT[F, A] and EitherT[F, A, B]. It requires Fx from Effectie and Monad from Cats. "},{"title":"Log F[A]​","type":1,"pageTitle":"Log - Cats","url":"/docs/v1/docs/cats-effect/log#log-fa","content":"Log[F].log(F[A])(A =&gt; LogMessage)  A given F[A], you can simply log A with log. "},{"title":"Example​","type":1,"pageTitle":"Log - Cats","url":"/docs/v1/docs/cats-effect/log#example","content":"import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ def hello[F[_]: Functor: Fx: Log](name: String): F[Unit] = log(pureOf(s&quot;Hello $name&quot;))(debug).map(println(_)) object MyApp extends IOApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp&quot;) def run(args: List[String]): IO[ExitCode] = for { _ &lt;- hello[IO](&quot;World&quot;) _ &lt;- hello[IO](&quot;Kevin&quot;) } yield ExitCode.Success }  23:34:25.021 [ioapp-compute-1] DEBUG MyApp - Hello World Hello World 23:34:25.022 [ioapp-compute-1] DEBUG MyApp - Hello Kevin Hello Kevin  trait Named[A] { def name(a: A): String } object Named { def apply[A: Named]: Named[A] = implicitly[Named[A]] } final case class GivenName(givenName: String) extends AnyVal final case class Surname(surname: String) extends AnyVal final case class Person(givenName: GivenName, surname: Surname) object Person { implicit val namedPerson: Named[Person] = person =&gt; s&quot;${person.givenName.givenName} ${person.surname.surname}&quot; } import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Fx import effectie.cats.ConsoleEffect import effectie.cats.Effectful._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ trait Greeting[F[_]] { def greet[A: Named](a: A): F[String] } object Greeting { def apply[F[_] : Greeting]: Greeting[F] = implicitly[Greeting[F]] implicit def hello[F[_]: Fx: Monad: Log]: Greeting[F] = new Greeting[F] { def greet[A: Named](a: A): F[String] = for { name &lt;- log(effectOf(Named[A].name(a)))(x =&gt; info(s&quot;The name is $x&quot;)) greeting &lt;- pureOf(s&quot;Hello $name&quot;) } yield greeting } } object MyApp extends IOApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp&quot;) def run(args: List[String]): IO[ExitCode] = for { greetingMessage &lt;- Greeting[IO].greet(Person(GivenName(&quot;Kevin&quot;), Surname(&quot;Lee&quot;))) _ &lt;- ConsoleEffect[IO].putStrLn(greetingMessage) } yield ExitCode.Success }  21:02:15.323 [ioapp-compute-0] INFO MyApp - The name is Kevin Lee Hello Kevin Lee  "},{"title":"Log F[Option[A]]​","type":1,"pageTitle":"Log - Cats","url":"/docs/v1/docs/cats-effect/log#log-foptiona","content":"Log[Option[F]].log( F[Option[A]] )( ifEmpty: =&gt; LogMessage with MaybeIgnorable, toLeveledMessage: A =&gt; LogMessage with MaybeIgnorable )  A given F[Option[A]], you can simply log Some(A) or None with log. "},{"title":"Example​","type":1,"pageTitle":"Log - Cats","url":"/docs/v1/docs/cats-effect/log#example-1","content":"import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ def greeting[F[_]: Fx](name: String): F[String] = pureOf(s&quot;Hello $name&quot;) def hello[F[_]: Monad: Fx: Log](maybeName: Option[String]): F[Unit] = for { name &lt;- log(pureOf(maybeName))( warn(&quot;No name given&quot;), name =&gt; info(s&quot;Name: $name&quot;) ) message &lt;- log(name.traverse(greeting[F]))(ignore, msg =&gt; info(s&quot;Message: $msg&quot;)) _ &lt;- effectOf(message.foreach(msg =&gt; println(msg))) } yield () implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp- F[Option[A]]&quot;) // canLog: CanLog = loggerf.logger.Slf4JLogger@3043de9c def run(): IO[Unit] = for { _ &lt;- hello[IO](none) _ &lt;- hello[IO](&quot;Kevin&quot;.some) } yield () run().unsafeRunSync() // Hello Kevin  20:09:43.117 [Thread-31] WARN MyApp- F[Option[A]] - No name given 20:09:43.133 [Thread-31] INFO MyApp- F[Option[A]] - Name: Kevin 20:09:43.133 [Thread-31] INFO MyApp- F[Option[A]] - Message: Hello Kevin  "},{"title":"Log F[Either[A, B]]​","type":1,"pageTitle":"Log - Cats","url":"/docs/v1/docs/cats-effect/log#log-feithera-b","content":"Log[Either[F]].log( F[Either[A, B]] )( leftToMessage: A =&gt; LeveledMessage with MaybeIgnorable, rightToMessage: B =&gt; LeveledMessage with MaybeIgnorable )  A given F[Either[A, B]], you can simply log Left(A) or Right(B) with log. "},{"title":"Example​","type":1,"pageTitle":"Log - Cats","url":"/docs/v1/docs/cats-effect/log#example-2","content":"import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ def foo[F[_]: Fx](a: Int): F[Int] = pureOf(a * 2) def divide[F[_]: Fx: CanHandleError](a: Int, b: Int): F[Either[String, Int]] = CanHandleError[F].handleNonFatal(effectOf((a / b).asRight[String])){ err =&gt; err.getMessage.asLeft[Int] } def calculate[F[_]: Monad: Fx: CanHandleError: Log](n: Int): F[Unit] = for { a &lt;- log(foo(n))( n =&gt; info(s&quot;n: ${n.toString}&quot;) ) result &lt;- log(divide(1000, a))( err =&gt; error(s&quot;Error: $err&quot;), r =&gt; info(s&quot;Result: ${r.toString}&quot;) ) _ &lt;- effectOf(println(result.fold(err =&gt; s&quot;Error: $err&quot;, r =&gt; s&quot;1000 / ${a.toString} = ${r.toString}&quot;))) } yield () implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp - F[Either[A, B]]&quot;) // canLog: CanLog = loggerf.logger.Slf4JLogger@69c1296d def run(): IO[Unit] = for { _ &lt;- calculate[IO](5) _ &lt;- calculate[IO](0) } yield () run().unsafeRunSync() // 1000 / 10 = 100 // Error: / by zero  20:20:05.588 [Thread-47] INFO MyApp - F[Either[A, B]] - n: 10 20:20:05.593 [Thread-47] INFO MyApp - F[Either[A, B]] - Result: 100 20:20:05.595 [Thread-47] INFO MyApp - F[Either[A, B]] - n: 0 20:20:05.605 [Thread-47] ERROR MyApp - F[Either[A, B]] - Error: / by zero  "},{"title":"Log OptionT[F, A]​","type":1,"pageTitle":"Log - Cats","url":"/docs/v1/docs/cats-effect/log#log-optiontf-a","content":""},{"title":"Log EitherT[F, A, B]​","type":1,"pageTitle":"Log - Cats","url":"/docs/v1/docs/cats-effect/log#log-eithertf-a-b","content":""},{"title":"Log - Monix","type":0,"sectionRef":"#","url":"/docs/v1/docs/monix/log","content":"","keywords":""},{"title":"Log - Monix (WIP)​","type":1,"pageTitle":"Log - Monix","url":"/docs/v1/docs/monix/log#log---monix-wip","content":"Log is a typeclass to log F[A], F[Option[A]], F[Either[A, B]], OptionT[F, A] and EitherT[F, A, B]. It requires Fx from Effectie and Monad from Cats. "},{"title":"Log F[A]​","type":1,"pageTitle":"Log - Monix","url":"/docs/v1/docs/monix/log#log-fa","content":"Log[F].log(F[A])(A =&gt; String)  "},{"title":"Example​","type":1,"pageTitle":"Log - Monix","url":"/docs/v1/docs/monix/log#example","content":"trait Named[A] { def name(a: A): String } object Named { def apply[A: Named]: Named[A] = implicitly[Named[A]] } final case class GivenName(givenName: String) extends AnyVal final case class Surname(surname: String) extends AnyVal final case class Person(givenName: GivenName, surname: Surname) object Person { implicit val namedPerson: Named[Person] = person =&gt; s&quot;${person.givenName.givenName} ${person.surname.surname}&quot; } import cats._ import cats.syntax.all._ import cats.effect.ExitCode import effectie.monix.{ConsoleEffect, Fx} import effectie.monix.Effectful._ import loggerf.logger._ import loggerf.monix._ import loggerf.syntax._ import monix.eval.Task import monix.eval.TaskApp trait Greeting[F[_]] { def greet[A: Named](a: A): F[String] } object Greeting { def apply[F[_]: Greeting]: Greeting[F] = implicitly[Greeting[F]] implicit def hello[F[_]: Fx: Monad: Log]: Greeting[F] = new Greeting[F] { def greet[A: Named](a: A): F[String] = for { name &lt;- log(effectOf(Named[A].name(a)))(x =&gt; info(s&quot;The name is $x&quot;)) greeting &lt;- pureOf(s&quot;Hello $name&quot;) } yield greeting } } object TaskMainApp extends TaskApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp&quot;) def run(args: List[String]): Task[ExitCode] = for { greetingMessage &lt;- Greeting[Task].greet( Person(GivenName(&quot;Kevin&quot;), Surname(&quot;Lee&quot;)) ) _ &lt;- ConsoleEffect[Task].putStrLn(greetingMessage) } yield ExitCode.Success }  19:57:04.076 [scala-execution-context-global-21] INFO MyApp - The name is Kevin Lee Hello Kevin Lee  "},{"title":"Log F[Option[A]]​","type":1,"pageTitle":"Log - Monix","url":"/docs/v1/docs/monix/log#log-foptiona","content":""},{"title":"Log OptionT[F, A]​","type":1,"pageTitle":"Log - Monix","url":"/docs/v1/docs/monix/log#log-optiontf-a","content":""},{"title":"Log F[Either[A, B]]​","type":1,"pageTitle":"Log - Monix","url":"/docs/v1/docs/monix/log#log-feithera-b","content":""},{"title":"Log EitherT[F, A, B]​","type":1,"pageTitle":"Log - Monix","url":"/docs/v1/docs/monix/log#log-eithertf-a-b","content":""},{"title":"Get LoggerF","type":0,"sectionRef":"#","url":"/docs/v1/docs/scalaz-effect/getting-started","content":"","keywords":""},{"title":"Get LoggerF For Scalaz Effect​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/scalaz-effect/getting-started#get-loggerf-for-scalaz-effect","content":"In build.sbt, &quot;io.kevinlee&quot; %% &quot;logger-f-scalaz-effect&quot; % &quot;1.20.0&quot;  "},{"title":"With SLF4J​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/scalaz-effect/getting-started#with-slf4j","content":"To use logger-f with SLF4J, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-slf4j&quot; % &quot;1.20.0&quot;  "},{"title":"With Log4j​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/scalaz-effect/getting-started#with-log4j","content":"To use logger-f with Log4j, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-log4j&quot; % &quot;1.20.0&quot;  "},{"title":"With Log4s​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/scalaz-effect/getting-started#with-log4s","content":"To use logger-f with Log4s, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-log4s&quot; % &quot;1.20.0&quot;  "},{"title":"With sbt Logging Util​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/scalaz-effect/getting-started#with-sbt-logging-util","content":"You probably need logger-f for sbt plugin development. &quot;io.kevinlee&quot; %% &quot;logger-f-sbt-logging&quot; % &quot;1.20.0&quot;  "},{"title":"Log​","type":1,"pageTitle":"Get LoggerF","url":"/docs/v1/docs/scalaz-effect/getting-started#log","content":""},{"title":"Log - Scalaz","type":0,"sectionRef":"#","url":"/docs/v1/docs/scalaz-effect/log","content":"","keywords":""},{"title":"Log - Scalaz (WIP)​","type":1,"pageTitle":"Log - Scalaz","url":"/docs/v1/docs/scalaz-effect/log#log---scalaz-wip","content":"Log is a typeclass to log F[A], F[Option[A]], F[A \\/ B], OptionT[F, A] and EitherT[F, A, B]. It requires Fx from Effectie and Monad from Scalaz. "},{"title":"Log F[A]​","type":1,"pageTitle":"Log - Scalaz","url":"/docs/v1/docs/scalaz-effect/log#log-fa","content":"Log[F].log(F[A])(A =&gt; String)  "},{"title":"Example​","type":1,"pageTitle":"Log - Scalaz","url":"/docs/v1/docs/scalaz-effect/log#example","content":"trait Named[A] { def name(a: A): String } object Named { def apply[A: Named]: Named[A] = implicitly[Named[A]] } final case class GivenName(givenName: String) extends AnyVal final case class Surname(surname: String) extends AnyVal final case class Person(givenName: GivenName, surname: Surname) object Person { implicit val namedPerson: Named[Person] = person =&gt; s&quot;${person.givenName.givenName} ${person.surname.surname}&quot; } import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz.Fx import effectie.scalaz.ConsoleEffect import effectie.scalaz.Effectful._ import loggerf.logger._ import loggerf.scalaz._ import loggerf.syntax._ trait Greeting[F[_]] { def greet[A: Named](a: A): F[String] } object Greeting { def apply[F[_] : Greeting]: Greeting[F] = implicitly[Greeting[F]] implicit def hello[F[_]: Fx: Monad: Log]: Greeting[F] = new Greeting[F] { def greet[A: Named](a: A): F[String] = for { name &lt;- log(effectOf(Named[A].name(a)))(x =&gt; info(s&quot;The name is $x&quot;)) greeting &lt;- pureOf(s&quot;Hello $name&quot;) } yield greeting } } object MyApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp&quot;) def run(args: List[String]): IO[Unit] = for { greetingMessage &lt;- Greeting[IO].greet(Person(GivenName(&quot;Kevin&quot;), Surname(&quot;Lee&quot;))) _ &lt;- ConsoleEffect[IO].putStrLn(greetingMessage) } yield () def main(args: Array[String]): Unit = run(args.toList).unsafePerformIO() }  21:02:15.323 [ioapp-compute-0] INFO MyApp - The name is Kevin Lee Hello Kevin Lee  "},{"title":"Log F[Option[A]]​","type":1,"pageTitle":"Log - Scalaz","url":"/docs/v1/docs/scalaz-effect/log#log-foptiona","content":""},{"title":"Log OptionT[F, A]​","type":1,"pageTitle":"Log - Scalaz","url":"/docs/v1/docs/scalaz-effect/log#log-optiontf-a","content":""},{"title":"Log F[A \\/ B]​","type":1,"pageTitle":"Log - Scalaz","url":"/docs/v1/docs/scalaz-effect/log#log-fa--b","content":""},{"title":"Log EitherT[F, A, B]​","type":1,"pageTitle":"Log - Scalaz","url":"/docs/v1/docs/scalaz-effect/log#log-eithertf-a-b","content":""},{"title":"Get LoggerF","type":0,"sectionRef":"#","url":"/docs/cats/","content":"","keywords":""},{"title":"Get LoggerF for Cats​","type":1,"pageTitle":"Get LoggerF","url":"/docs/cats/#get-loggerf-for-cats","content":"In build.sbt, &quot;io.kevinlee&quot; %% &quot;logger-f-cats&quot; % &quot;2.0.0-beta9&quot;  "},{"title":"With SLF4J​","type":1,"pageTitle":"Get LoggerF","url":"/docs/cats/#with-slf4j","content":"To use logger-f with SLF4J, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-slf4j&quot; % &quot;2.0.0-beta9&quot;  "},{"title":"With Log4j​","type":1,"pageTitle":"Get LoggerF","url":"/docs/cats/#with-log4j","content":"To use logger-f with Log4j, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-log4j&quot; % &quot;2.0.0-beta9&quot;  "},{"title":"With Log4s​","type":1,"pageTitle":"Get LoggerF","url":"/docs/cats/#with-log4s","content":"To use logger-f with Log4s, add the following logger &quot;io.kevinlee&quot; %% &quot;logger-f-log4s&quot; % &quot;2.0.0-beta9&quot;  "},{"title":"With sbt Logging Util​","type":1,"pageTitle":"Get LoggerF","url":"/docs/cats/#with-sbt-logging-util","content":"You probably need logger-f for sbt plugin development. &quot;io.kevinlee&quot; %% &quot;logger-f-sbt-logging&quot; % &quot;2.0.0-beta9&quot;  "},{"title":"Log​","type":1,"pageTitle":"Get LoggerF","url":"/docs/cats/#log","content":""},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/","content":"","keywords":""},{"title":" LoggerF - Logger for F[_]​","type":1,"pageTitle":"Getting Started","url":"/docs/#-loggerf---logger-for-f_","content":"LoggerF is a tool for logging tagless final with an effect library. LoggerF requires Effectie to construct F[_]. All the example code in this doc site uses Effectie so if you're not familiar with it, please check out Effectie website. Why LoggerF? Why not just log with map or flatMap? Please read &quot;Why?&quot; section. "},{"title":"Getting Started​","type":1,"pageTitle":"Getting Started","url":"/docs/#getting-started","content":""},{"title":"Get LoggerF For Cats Effect​","type":1,"pageTitle":"Getting Started","url":"/docs/#get-loggerf-for-cats-effect","content":""},{"title":"Get LoggerF For Cats​","type":1,"pageTitle":"Getting Started","url":"/docs/#get-loggerf-for-cats","content":"logger-f can be used wit any effect library or Future as long as there is an instance of Fx from effectie. With SLF4J​ In build.sbt, libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-cats&quot; % &quot;2.0.0-beta9&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-slf4j&quot; % &quot;2.0.0-beta9&quot; )  With Log4j​ libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-cats&quot; % &quot;2.0.0-beta9&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-log4j&quot; % &quot;2.0.0-beta9&quot; )  With Log4s​ libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-cats&quot; % &quot;2.0.0-beta9&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-log4s&quot; % &quot;2.0.0-beta9&quot; )  With sbt Logging Util​ You probably need logger-f for sbt plugin development. libraryDependencies ++= Seq( &quot;io.kevinlee&quot; %% &quot;logger-f-cats&quot; % &quot;2.0.0-beta9&quot;, &quot;io.kevinlee&quot; %% &quot;logger-f-sbt-logging&quot; % &quot;2.0.0-beta9&quot; )  "},{"title":"Why​","type":1,"pageTitle":"Getting Started","url":"/docs/#why","content":""},{"title":"Log without LoggerF​","type":1,"pageTitle":"Getting Started","url":"/docs/#log-without-loggerf","content":"If you code tagless final and use some effect library like Cats Effect and Monix or use Future, you may have inconvenience in logging. What inconvenience? I can just log with flatMap like. for { a &lt;- foo(n) // F[A] _ &lt;- Sync[F].delay(logger.debug(s&quot;a is $a&quot;)) // F[Unit] b &lt;- bar(a) // F[B] _ &lt;- Sync[F].delay(logger.debug(s&quot;b is $b&quot;)) // F[Unit] } yield b  That's true, but it's distracting to have log in each flatMap. So, 1 line for the actual code 1 line for logging 1 line for the actual code 1 line for logging  "},{"title":"Log wit LoggerF​","type":1,"pageTitle":"Getting Started","url":"/docs/#log-wit-loggerf","content":"It can be simplified by logger-f. for { a &lt;- foo(n).log(a =&gt; debug(s&quot;a is $a&quot;)) // F[A] b &lt;- bar(a).log(b =&gt; debug(s&quot;b is $b&quot;)) // F[B] } yield b   "},{"title":"Log without LoggerF (Option and OptionT)​","type":1,"pageTitle":"Getting Started","url":"/docs/#log-without-loggerf-option-and-optiont","content":"What about F[_] with Option and Either? What happens if you want to use Option or Either? If you use F[_] with Option or Either, you may have more inconvenience or may not get the result you want. e.g.) import cats.syntax.all._ import cats.effect._ import org.slf4j.LoggerFactory val logger = LoggerFactory.getLogger(&quot;test-logger&quot;) // logger: org.slf4j.Logger = Logger[test-logger] def foo[F[_]: Sync](n: Int): F[Option[Int]] = for { a &lt;- Sync[F].pure(n.some) _ &lt;- Sync[F].delay( a match { case Some(value) =&gt; logger.debug(s&quot;a is $value&quot;) case None =&gt; logger.debug(&quot;No 'a' value found&quot;) } ) // F[Unit] b &lt;- Sync[F].pure(none[Int]) _ &lt;- Sync[F].delay( b match { case Some(value) =&gt; logger.debug(s&quot;b is $value&quot;) case None =&gt; () // don't log anything for None case } ) // F[Unit] c &lt;- Sync[F].pure(123.some) _ &lt;- Sync[F].delay( c match { case Some(value) =&gt; () // don't log anything for None case case None =&gt; logger.debug(&quot;No 'c' value found&quot;) } ) // F[Unit] } yield c  So much noise for logging! Now, let's think about the result. foo[IO](1).unsafeRunSync() // You probably want to have None here. // res1: Option[Int] = Some(value = 123)  You expect None for the result due to Sync[F].pure(none[Int]) yet you get Some(123) instead. That's because b is from F[Option[Int]] not from Option[Int]. The same issue exists for F[Either[A, B]] as well. So you need to use OptionT for F[Option[A]] and EitherT for F[Either[A, B]]. Let's write it again with OptionT. import cats.data._ import cats.syntax.all._ import cats.effect._ import org.slf4j.LoggerFactory val logger = LoggerFactory.getLogger(&quot;test-logger&quot;) // logger: org.slf4j.Logger = Logger[test-logger] def foo[F[_]: Sync](n: Int): F[Option[Int]] = (for { a &lt;- OptionT(Sync[F].pure(n.some)) _ &lt;- OptionT.liftF(Sync[F].delay(logger.debug(s&quot;a is $a&quot;))) // Now, you can't log None case. b &lt;- OptionT(Sync[F].pure(none[Int])) _ &lt;- OptionT.liftF(Sync[F].delay(logger.debug(s&quot;b is $b&quot;))) // You can't log None case. c &lt;- OptionT(Sync[F].pure(123.some)) _ &lt;- OptionT.liftF(Sync[F].delay(logger.debug(s&quot;c is $c&quot;))) // You can't log None case. } yield c).value  foo[IO](1).unsafeRunSync() // You expect None here. // res3: Option[Int] = None  The problem's gone! Now each flatMap handles only Some case and that's what you want. However, because of that, it's hard to log None case.  "},{"title":"Log with LoggerF (Option and OptionT)​","type":1,"pageTitle":"Getting Started","url":"/docs/#log-with-loggerf-option-and-optiont","content":"LoggerF can solve this issue for you! import cats._ import cats.data._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ import loggerf.core._ import loggerf.syntax.all._ def foo[F[_]: Fx: Monad: Log](n: Int): F[Option[Int]] = (for { a &lt;- OptionT(effectOf(n.some)).log( ifEmpty = error(&quot;a is empty&quot;), a =&gt; debug(s&quot;a is $a&quot;) ) b &lt;- OptionT(effectOf(none[Int])).log( error(&quot;b is empty&quot;), b =&gt; debug(s&quot;b is $b&quot;) ) c &lt;- OptionT(effectOf(123.some)).log( warn(&quot;c is empty&quot;), c =&gt; debug(s&quot;c is $c&quot;) ) } yield c).value  import loggerf.logger._ // or Slf4JLogger.slf4JLogger[MyClass] implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyLogger&quot;) // canLog: CanLog = loggerf.logger.Slf4JLogger@5a3f1c5c import effectie.instances.ce2.fx._ import loggerf.instances.cats._ foo[IO](1).unsafeRunSync() // You expect None here. // res5: Option[Int] = None  With logs like 00:17:33.983 [main] DEBUG MyLogger - a is 1 00:17:33.995 [main] ERROR MyLogger - b is empty   "},{"title":"Log with LoggerF (EitherT)​","type":1,"pageTitle":"Getting Started","url":"/docs/#log-with-loggerf-eithert","content":"Another example with EitherT (F[Either[A, B]] case is similar), import cats._ import cats.data._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ import loggerf.core._ import loggerf.syntax.all._ def foo[F[_]: Fx: Monad: Log](n: Int): F[Either[String, Int]] = (for { a &lt;- EitherT(effectOf(n.asRight[String])).log( err =&gt; error(s&quot;Error: $err&quot;), a =&gt; debug(s&quot;a is $a&quot;) ) b &lt;- EitherT(effectOf(&quot;Some Error&quot;.asLeft[Int])).log( err =&gt; error(s&quot;Error: $err&quot;), b =&gt; debug(s&quot;b is $b&quot;) ) c &lt;- EitherT(effectOf(123.asRight[String])).log( err =&gt; warn(s&quot;Error: $err&quot;), c =&gt; debug(s&quot;c is $c&quot;) ) } yield c).value  import loggerf.logger._ // or Slf4JLogger.slf4JLogger[MyClass] implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyLogger&quot;) // canLog: CanLog = loggerf.logger.Slf4JLogger@5cec898 import effectie.instances.ce2.fx._ import loggerf.instances.cats._ foo[IO](1).unsafeRunSync() // You expect Left(&quot;Some Error&quot;) here. // res7: Either[String, Int] = Left(value = &quot;Some Error&quot;)  With logs like 00:40:48.663 [main] DEBUG MyLogger - a is 1 00:40:48.667 [main] ERROR MyLogger - Error: Some Error  "},{"title":"Usage​","type":1,"pageTitle":"Getting Started","url":"/docs/#usage","content":"Please check out LoggerF for Cats "},{"title":"Log - Cats","type":0,"sectionRef":"#","url":"/docs/cats/log","content":"","keywords":""},{"title":"Log - Cats (WIP)​","type":1,"pageTitle":"Log - Cats","url":"/docs/cats/log#log---cats-wip","content":"Log is an algebra to log F[A], F[Option[A]], F[Either[A, B]], OptionT[F, A] and EitherT[F, A, B]. So Log provides abstraction of logging operations, and there can multiple interpretations if required. More precisely, it requires Fx from Effectie and Monad from Cats. So it can be used for whatever effect you want as long as there's an interpreter for Fx of the effect. "},{"title":"Log String​","type":1,"pageTitle":"Log - Cats","url":"/docs/cats/log#log-string","content":"LoggerF is mainly for F[_] but let's start with more simple logging case that is logging String. With syntaxWithout syntax logS(String)(debug) // F[String] logS(String)(info) // F[String] logS(String)(warn) // F[String] logS(String)(error) // F[String] // or String.logS(debug) // F[String] String.logS(info) // F[String] String.logS(warn) // F[String] String.logS(error) // F[String] If you don't need to re-use the String value, import loggerf.syntax.all._ logS_(String)(debug) // F[Unit] logS_(String)(info) // F[Unit] logS_(String)(warn) // F[Unit] logS_(String)(error) // F[Unit] // or String.logS_(debug) // F[Unit] String.logS_(info) // F[Unit] String.logS_(warn) // F[Unit] String.logS_(error) // F[Unit]  "},{"title":"Example​","type":1,"pageTitle":"Log - Cats","url":"/docs/cats/log#example","content":"With syntaxWithout syntax import cats._ import cats.syntax.all._ import effectie.core._ import effectie.syntax.all._ import loggerf.core._ import loggerf.syntax.all._ def hello[F[_]: Fx: Log: Monad](name: String): F[Unit] = for { greeting &lt;- logS(s&quot;[1] Hello $name&quot;)(info) // F[String] _ &lt;- effectOf(println(greeting)) // F[Unit] // Or greeting2 &lt;- s&quot;[2] Hello $name&quot;.logS(info) // F[String] _ &lt;- effectOf(println(greeting2)) // F[Unit] } yield () import cats.effect._ import effectie.instances.ce2.fx._ import loggerf.instances.cats._ import loggerf.logger._ implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;test-logger&quot;) // canLog: CanLog = loggerf.logger.Slf4JLogger@5cbc03ed hello[IO](&quot;Kevin&quot;).unsafeRunSync() // [1] Hello Kevin // [2] Hello Kevin 22:52:36.970 [Thread-64] INFO test-logger - [1] Hello Kevin 22:52:36.977 [Thread-64] INFO test-logger - [2] Hello Kevin If you don't need to re-use the String value, import cats._ import cats.syntax.all._ import effectie.core._ import effectie.syntax.all._ import loggerf.core._ import loggerf.syntax.all._ def hello[F[_]: Fx: Log: Monad](name: String): F[Unit] = for { _ &lt;- logS_(s&quot;[1] The name is $name&quot;)(info) // F[Unit] // Or _ &lt;- s&quot;[2] The name is $name&quot;.logS_(info) // F[Unit] _ &lt;- effectOf(println(s&quot;Hello $name&quot;)) // F[Unit] } yield () import cats.effect._ import effectie.instances.ce2.fx._ import loggerf.instances.cats._ import loggerf.logger._ implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;test-logger&quot;) // canLog: CanLog = loggerf.logger.Slf4JLogger@5a17e2a hello[IO](&quot;Kevin&quot;).unsafeRunSync() // Hello Kevin 22:53:09.165 [Thread-66] INFO test-logger - [1] The name is Kevin 22:53:09.166 [Thread-66] INFO test-logger - [2] The name is Kevin  "},{"title":"Log F[A]​","type":1,"pageTitle":"Log - Cats","url":"/docs/cats/log#log-fa","content":"Log[F].log(F[A])(A =&gt; LogMessage) // F[A]  or with loggerf.syntax F[A].log(A =&gt; LogMessage) // F[A]  A given F[A], you can simply log A with log. With SyntaxWithout Syntax import effectie.core._ import loggerf.core._ import loggerf.syntax.all._ def count[F[_]: Fx: Log](): F[Count] = counter.currentCount() // F[Count] .log(count =&gt; info(s&quot;Current count: $count&quot;)) // F[Count]  "},{"title":"Example​","type":1,"pageTitle":"Log - Cats","url":"/docs/cats/log#example-1","content":"import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ import loggerf.core._ import loggerf.syntax.all._ import loggerf.logger._ def hello[F[_]: Functor: Fx: Log](name: String): F[Unit] = s&quot;Hello $name&quot;.logS(debug).map(println(_)) object MyApp extends IOApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp&quot;) import effectie.instances.ce2.fx._ import loggerf.instances.cats._ def run(args: List[String]): IO[ExitCode] = for { _ &lt;- hello[IO](&quot;World&quot;) _ &lt;- hello[IO](&quot;Kevin&quot;) } yield ExitCode.Success }  23:34:25.021 [ioapp-compute-1] DEBUG MyApp - Hello World Hello World 23:34:25.022 [ioapp-compute-1] DEBUG MyApp - Hello Kevin Hello Kevin  trait Named[A] { def name(a: A): String } object Named { def apply[A: Named]: Named[A] = implicitly[Named[A]] } final case class GivenName(givenName: String) extends AnyVal final case class Surname(surname: String) extends AnyVal final case class Person(givenName: GivenName, surname: Surname) object Person { implicit val namedPerson: Named[Person] = person =&gt; s&quot;${person.givenName.givenName} ${person.surname.surname}&quot; } import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ import loggerf.core._ import loggerf.syntax.all._ import loggerf.logger._ trait Greeting[F[_]] { def greet[A: Named](a: A): F[String] } object Greeting { def apply[F[_] : Greeting]: Greeting[F] = implicitly[Greeting[F]] implicit def hello[F[_]: Fx: Monad: Log]: Greeting[F] = new Greeting[F] { def greet[A: Named](a: A): F[String] = for { name &lt;- effectOf(Named[A].name(a)).log(x =&gt; info(s&quot;The name is $x&quot;)) greeting &lt;- pureOf(s&quot;Hello $name&quot;) } yield greeting } } object MyApp extends IOApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp&quot;) import effectie.instances.ce2.fx._ import loggerf.instances.cats._ import effectie.instances.console._ def run(args: List[String]): IO[ExitCode] = for { greetingMessage &lt;- Greeting[IO].greet(Person(GivenName(&quot;Kevin&quot;), Surname(&quot;Lee&quot;))) _ &lt;- ConsoleEffect[IO].putStrLn(greetingMessage) } yield ExitCode.Success }  21:02:15.323 [ioapp-compute-0] INFO MyApp - The name is Kevin Lee Hello Kevin Lee  "},{"title":"Log F[Option[A]]​","type":1,"pageTitle":"Log - Cats","url":"/docs/cats/log#log-foptiona","content":"Log[Option[F]].log( F[Option[A]] )( ifEmpty: =&gt; LogMessage with MaybeIgnorable, toLeveledMessage: A =&gt; LogMessage with MaybeIgnorable )  A given F[Option[A]], you can simply log Some(A) or None with log. "},{"title":"Example​","type":1,"pageTitle":"Log - Cats","url":"/docs/cats/log#example-2","content":"import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ import loggerf.core._ import loggerf.syntax.all._ import loggerf.logger._ def greeting[F[_]: Fx](name: String): F[String] = pureOf(s&quot;Hello $name&quot;) def hello[F[_]: Monad: Fx: Log](maybeName: Option[String]): F[Unit] = for { name &lt;- pureOf(maybeName).log( warn(&quot;No name given&quot;), name =&gt; info(s&quot;Name: $name&quot;) ) message &lt;- name.traverse(greeting[F]).log(ignore, msg =&gt; info(s&quot;Message: $msg&quot;)) _ &lt;- effectOf(message.foreach(msg =&gt; println(msg))) } yield () implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp- F[Option[A]]&quot;) // canLog: CanLog = loggerf.logger.Slf4JLogger@242e692d import effectie.instances.ce2.fx._ import loggerf.instances.cats._ def run(): IO[Unit] = for { _ &lt;- hello[IO](none) _ &lt;- hello[IO](&quot;Kevin&quot;.some) } yield () run().unsafeRunSync() // Hello Kevin  20:09:43.117 [Thread-31] WARN MyApp- F[Option[A]] - No name given 20:09:43.133 [Thread-31] INFO MyApp- F[Option[A]] - Name: Kevin 20:09:43.133 [Thread-31] INFO MyApp- F[Option[A]] - Message: Hello Kevin  "},{"title":"Log F[Either[A, B]]​","type":1,"pageTitle":"Log - Cats","url":"/docs/cats/log#log-feithera-b","content":"Log[Either[F]].log( F[Either[A, B]] )( leftToMessage: A =&gt; LeveledMessage with MaybeIgnorable, rightToMessage: B =&gt; LeveledMessage with MaybeIgnorable )  A given F[Either[A, B]], you can simply log Left(A) or Right(B) with log. "},{"title":"Example​","type":1,"pageTitle":"Log - Cats","url":"/docs/cats/log#example-3","content":"import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ import loggerf.core._ import loggerf.syntax.all._ import loggerf.logger._ def foo[F[_]: Fx](a: Int): F[Int] = pureOf(a * 2) def divide[F[_]: Fx: CanHandleError](a: Int, b: Int): F[Either[String, Int]] = effectOf((a / b).asRight[String]) .handleNonFatal{ err =&gt; err.getMessage.asLeft[Int] } def calculate[F[_]: Monad: Fx: CanHandleError: Log](n: Int): F[Unit] = for { a &lt;- foo(n).log( n =&gt; info(s&quot;n: ${n.toString}&quot;) ) result &lt;- divide(1000, a).log( err =&gt; error(s&quot;Error: $err&quot;), r =&gt; info(s&quot;Result: ${r.toString}&quot;) ) _ &lt;- effectOf(println(result.fold(err =&gt; s&quot;Error: $err&quot;, r =&gt; s&quot;1000 / ${a.toString} = ${r.toString}&quot;))) } yield () implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(&quot;MyApp - F[Either[A, B]]&quot;) // canLog: CanLog = loggerf.logger.Slf4JLogger@2a7003ac import effectie.instances.ce2.fx._ import loggerf.instances.cats._ def run(): IO[Unit] = for { _ &lt;- calculate[IO](5) _ &lt;- calculate[IO](0) } yield () run().unsafeRunSync() // 1000 / 10 = 100 // Error: / by zero  20:20:05.588 [Thread-47] INFO MyApp - F[Either[A, B]] - n: 10 20:20:05.593 [Thread-47] INFO MyApp - F[Either[A, B]] - Result: 100 20:20:05.595 [Thread-47] INFO MyApp - F[Either[A, B]] - n: 0 20:20:05.605 [Thread-47] ERROR MyApp - F[Either[A, B]] - Error: / by zero  "},{"title":"Log OptionT[F, A]​","type":1,"pageTitle":"Log - Cats","url":"/docs/cats/log#log-optiontf-a","content":""},{"title":"Log EitherT[F, A, B]​","type":1,"pageTitle":"Log - Cats","url":"/docs/cats/log#log-eithertf-a-b","content":""}]