"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[118],{1470:(e,n,r)=>{r.d(n,{A:()=>v});var a=r(6540),o=r(4164),l=r(7559),t=r(3104),i=r(6347),s=r(205),g=r(7485),c=r(1682),d=r(679);function f(e){return a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:n,children:r}=e;return(0,a.useMemo)(()=>{const e=n??function(e){return f(e).map(({props:{value:e,label:n,attributes:r,default:a}})=>({value:e,label:n,attributes:r,default:a}))}(r);return function(e){const n=(0,c.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,r])}function u({value:e,tabValues:n}){return n.some(n=>n.value===e)}function m({queryString:e=!1,groupId:n}){const r=(0,i.W6)(),o=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,g.aZ)(o),(0,a.useCallback)(e=>{if(!o)return;const n=new URLSearchParams(r.location.search);n.set(o,e),r.replace({...r.location,search:n.toString()})},[o,r])]}function h(e){const{defaultValue:n,queryString:r=!1,groupId:o}=e,l=p(e),[t,i]=(0,a.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!u({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const r=n.find(e=>e.default)??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:l})),[g,c]=m({queryString:r,groupId:o}),[f,h]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[r,o]=(0,d.Dv)(n);return[r,(0,a.useCallback)(e=>{n&&o.set(e)},[n,o])]}({groupId:o}),x=(()=>{const e=g??f;return u({value:e,tabValues:l})?e:null})();(0,s.A)(()=>{x&&i(x)},[x]);return{selectedValue:t,selectValue:(0,a.useCallback)(e=>{if(!u({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);i(e),c(e),h(e)},[c,h,l]),tabValues:l}}var x=r(2303);const F={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var y=r(4848);function S({className:e,block:n,selectedValue:r,selectValue:a,tabValues:l}){const i=[],{blockElementScrollPositionUntilNextRender:s}=(0,t.a_)(),g=e=>{const n=e.currentTarget,o=i.indexOf(n),t=l[o].value;t!==r&&(s(n),a(t))},c=e=>{let n=null;switch(e.key){case"Enter":g(e);break;case"ArrowRight":{const r=i.indexOf(e.currentTarget)+1;n=i[r]??i[0];break}case"ArrowLeft":{const r=i.indexOf(e.currentTarget)-1;n=i[r]??i[i.length-1];break}}n?.focus()};return(0,y.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":n},e),children:l.map(({value:e,label:n,attributes:a})=>(0,y.jsx)("li",{role:"tab",tabIndex:r===e?0:-1,"aria-selected":r===e,ref:e=>{i.push(e)},onKeyDown:c,onClick:g,...a,className:(0,o.A)("tabs__item",F.tabItem,a?.className,{"tabs__item--active":r===e}),children:n??e},e))})}function j({lazy:e,children:n,selectedValue:r}){const l=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=l.find(e=>e.props.value===r);return e?(0,a.cloneElement)(e,{className:(0,o.A)("margin-top--md",e.props.className)}):null}return(0,y.jsx)("div",{className:"margin-top--md",children:l.map((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r}))})}function _(e){const n=h(e);return(0,y.jsxs)("div",{className:(0,o.A)(l.G.tabs.container,"tabs-container",F.tabList),children:[(0,y.jsx)(S,{...n,...e}),(0,y.jsx)(j,{...n,...e})]})}function v(e){const n=(0,x.A)();return(0,y.jsx)(_,{...e,children:f(e.children)},String(n))}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>i});var a=r(6540);const o={},l=a.createContext(o);function t(e){const n=a.useContext(l);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),a.createElement(l.Provider,{value:n},e.children)}},9091:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>g,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"cats/log","title":"Log - Cats","description":"Log - Cats (WIP)","source":"@site/../generated-docs/docs/cats/log.md","sourceDirName":"cats","slug":"/cats/log","permalink":"/docs/cats/log","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"id":"log","title":"Log - Cats"},"sidebar":"docsSidebar","previous":{"title":"What to Import","permalink":"/docs/cats/import"}}');var o=r(4848),l=r(8453),t=r(1470),i=r(9365);const s={sidebar_position:3,id:"log",title:"Log - Cats"},g=void 0,c={},d=[{value:"Log - Cats (WIP)",id:"log---cats-wip",level:2},{value:"Log <code>String</code>",id:"log-string",level:2},{value:"Example",id:"example",level:3},{value:"Log <code>F[A]</code>",id:"log-fa",level:2},{value:"Example",id:"example-1",level:3},{value:"Log <code>F[Option[A]]</code>",id:"log-foptiona",level:2},{value:"Example",id:"example-2",level:3},{value:"Log <code>F[Either[A, B]]</code>",id:"log-feithera-b",level:2},{value:"Example",id:"example-3",level:3},{value:"Log <code>OptionT[F, A]</code>",id:"log-optiontf-a",level:2},{value:"Example",id:"example-4",level:3},{value:"Log <code>EitherT[F, A, B]</code>",id:"log-eithertf-a-b",level:2},{value:"Example",id:"example-5",level:3}];function f(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,l.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"log---cats-wip",children:"Log - Cats (WIP)"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Log"})," is an algebra to log ",(0,o.jsx)(n.code,{children:"F[A]"}),", ",(0,o.jsx)(n.code,{children:"F[Option[A]]"}),", ",(0,o.jsx)(n.code,{children:"F[Either[A, B]]"}),", ",(0,o.jsx)(n.code,{children:"OptionT[F, A]"})," and ",(0,o.jsx)(n.code,{children:"EitherT[F, A, B]"}),". So ",(0,o.jsx)(n.code,{children:"Log"})," provides abstraction of logging operations, and there can multiple interpretations if required."]}),"\n",(0,o.jsxs)(n.p,{children:["More precisely, it requires ",(0,o.jsx)(n.code,{children:"Fx"})," from ",(0,o.jsx)(n.a,{href:"https://kevin-lee.github.io/effectie",children:"Effectie"})," and ",(0,o.jsx)(n.code,{children:"Monad"})," from ",(0,o.jsx)(n.a,{href:"https://typelevel.org/cats",children:"Cats"}),". So it can be used for whatever effect you want as long as there's an interpreter for ",(0,o.jsx)(n.code,{children:"Fx"})," of the effect."]}),"\n",(0,o.jsxs)(n.h2,{id:"log-string",children:["Log ",(0,o.jsx)(n.code,{children:"String"})]}),"\n",(0,o.jsxs)(n.p,{children:["LoggerF is mainly for ",(0,o.jsx)(n.code,{children:"F[_]"})," but let's start with more simple logging case that is logging ",(0,o.jsx)(n.code,{children:"String"}),"."]}),"\n",(0,o.jsxs)(t.A,{groupId:"logS",defaultValue:"syntax",values:[{label:"With syntax",value:"syntax"},{label:"Without syntax",value:"no-syntax"}],children:[(0,o.jsxs)(i.A,{value:"syntax",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"logS(String)(debug) // F[String]\nlogS(String)(info)  // F[String]\nlogS(String)(warn)  // F[String]\nlogS(String)(error) // F[String]\n// or\nString.logS(debug) // F[String]\nString.logS(info)  // F[String]\nString.logS(warn)  // F[String]\nString.logS(error) // F[String]\n"})}),(0,o.jsxs)(n.p,{children:["If you don't need to re-use the ",(0,o.jsx)(n.code,{children:"String"})," value,"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import loggerf.syntax.all._\n\nlogS_(String)(debug) // F[Unit]\nlogS_(String)(info)  // F[Unit]\nlogS_(String)(warn)  // F[Unit]\nlogS_(String)(error) // F[Unit]\n// or\nString.logS_(debug) // F[Unit]\nString.logS_(info)  // F[Unit]\nString.logS_(warn)  // F[Unit]\nString.logS_(error) // F[Unit]\n"})})]}),(0,o.jsxs)(i.A,{value:"no-syntax",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import loggerf.core._\n\nLog[F].logS(String)(debug) // F[String]\nLog[F].logS(String)(info)  // F[String]\nLog[F].logS(String)(warn)  // F[String]\nLog[F].logS(String)(error) // F[String]\n"})}),(0,o.jsxs)(n.p,{children:["If you don't need to re-use the ",(0,o.jsx)(n.code,{children:"String"})," value,"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"Log[F].logS_(String)(debug) // F[Unit]\nLog[F].logS_(String)(info)  // F[Unit]\nLog[F].logS_(String)(warn)  // F[Unit]\nLog[F].logS_(String)(error) // F[Unit]\n"})})]})]}),"\n",(0,o.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,o.jsxs)(t.A,{groupId:"logS-example",defaultValue:"syntax",values:[{label:"With syntax",value:"syntax"},{label:"Without syntax",value:"no-syntax"}],children:[(0,o.jsxs)(i.A,{value:"syntax",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nimport loggerf.core._\nimport loggerf.syntax.all._\n\ndef hello[F[_]: Fx: Log: Monad](name: String): F[Unit] = for {\n  greeting <- logS(s"[1] Hello $name")(info)  // F[String]\n  _        <- effectOf(println(greeting)) // F[Unit]\n  // Or\n  greeting2 <- s"[2] Hello $name".logS(info)  // F[String]\n  _         <- effectOf(println(greeting2)) // F[Unit]\n} yield ()\n'})}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import cats.effect._\nimport effectie.instances.ce2.fx._\n\nimport loggerf.logger._\n\nimplicit val canLog: CanLog = Slf4JLogger.slf4JCanLog("test-logger")\n// canLog: CanLog = loggerf.logger.Slf4JLogger@64e000d4\n\nhello[IO]("Kevin").unsafeRunSync()\n// [1] Hello Kevin\n// [2] Hello Kevin\n'})}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"22:52:36.970 [Thread-64] INFO test-logger - [1] Hello Kevin\n22:52:36.977 [Thread-64] INFO test-logger - [2] Hello Kevin\n"})}),(0,o.jsx)(n.hr,{}),(0,o.jsxs)(n.p,{children:["If you don't need to re-use the ",(0,o.jsx)(n.code,{children:"String"})," value,"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nimport loggerf.core._\nimport loggerf.syntax.all._\n\ndef hello[F[_]: Fx: Log: Monad](name: String): F[Unit] = for {\n  _ <- logS_(s"[1] The name is $name")(info) // F[Unit]\n  // Or\n  _ <- s"[2] The name is $name".logS_(info)  // F[Unit]\n  \n  _ <- effectOf(println(s"Hello $name")) // F[Unit]\n} yield ()\n'})}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import cats.effect._\nimport effectie.instances.ce2.fx._\n\nimport loggerf.logger._\n\nimplicit val canLog: CanLog = Slf4JLogger.slf4JCanLog("test-logger")\n// canLog: CanLog = loggerf.logger.Slf4JLogger@690d6630\n\nhello[IO]("Kevin").unsafeRunSync()\n// Hello Kevin\n'})}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"22:53:09.165 [Thread-66] INFO test-logger - [1] The name is Kevin\n22:53:09.166 [Thread-66] INFO test-logger - [2] The name is Kevin\n"})})]}),(0,o.jsxs)(i.A,{value:"no-syntax",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nimport loggerf.core._\nimport loggerf.syntax.all._\n\ndef hello[F[_]: Fx: Log: Monad](name: String): F[Unit] = for {\n  greeting <- Log[F].logS(s"Hello $name")(info) // F[String]\n  _        <- effectOf(println(greeting))       // F[Unit]\n} yield ()\n'})}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import cats.effect._\nimport effectie.instances.ce2.fx._\n\nimport loggerf.logger._\n\nimplicit val canLog: CanLog = Slf4JLogger.slf4JCanLog("test-logger")\n// canLog: CanLog = loggerf.logger.Slf4JLogger@4251e776\n\nhello[IO]("Kevin").unsafeRunSync()\n// Hello Kevin\n'})}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"02:07:09.298 [Thread-67] INFO test-logger - Hello Kevin\n"})}),(0,o.jsx)(n.hr,{}),(0,o.jsxs)(n.p,{children:["If you don't need to re-use the ",(0,o.jsx)(n.code,{children:"String"})," value,"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nimport loggerf.core._\nimport loggerf.syntax.all._\n\ndef hello[F[_]: Fx: Log: Monad](name: String): F[Unit] = for {\n  _ <- logS_(s"The name is $name")(info) // F[Unit]\n  _ <- effectOf(println(s"Hello $name")) // F[Unit]\n} yield ()\n'})}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import cats.effect._\nimport effectie.instances.ce2.fx._\n\nimport loggerf.logger._\n\nimplicit val canLog: CanLog = Slf4JLogger.slf4JCanLog("test-logger")\n// canLog: CanLog = loggerf.logger.Slf4JLogger@748ccc5b\n\nhello[IO]("Kevin").unsafeRunSync()\n// Hello Kevin\n'})}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"02:15:41.367 [Thread-74] INFO test-logger - The name is Kevin\n"})})]})]}),"\n",(0,o.jsxs)(n.h2,{id:"log-fa",children:["Log ",(0,o.jsx)(n.code,{children:"F[A]"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"Log[F].log(F[A])(A => LogMessage) // F[A]\n"})}),"\n",(0,o.jsxs)(n.p,{children:["or with ",(0,o.jsx)(n.code,{children:"loggerf.syntax"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"F[A].log(A => LogMessage) // F[A]\n"})}),"\n",(0,o.jsxs)(n.p,{children:["A given ",(0,o.jsx)(n.code,{children:"F[A]"}),", you can simply log ",(0,o.jsx)(n.code,{children:"A"})," with ",(0,o.jsx)(n.code,{children:"log"}),"."]}),"\n",(0,o.jsxs)(t.A,{groupId:"log-fa",defaultValue:"syntax",values:[{label:"With Syntax",value:"syntax"},{label:"Without Syntax",value:"no-syntax"}],children:[(0,o.jsxs)(i.A,{value:"syntax",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import loggerf.syntax.all._\n\nval fa: F[A] = ...\nfa.log(a => debug(s"Some meesage: $a")) // F[A]\nfa.log(a => info(s"Some meesage: $a"))  // F[A]\nfa.log(a => warn(s"Some meesage: $a"))  // F[A]\nfa.log(a => error(s"Some meesage: $a")) // F[A]\n// OR\nlog(fa)(a => debug(s"Some meesage: $a")) // F[A]\nlog(fa)(a => info(s"Some meesage: $a"))  // F[A]\nlog(fa)(a => warn(s"Some meesage: $a"))  // F[A]\nlog(fa)(a => error(s"Some meesage: $a")) // F[A]\n'})}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import effectie.core._\nimport loggerf.core._\nimport loggerf.syntax.all._\n\ndef count[F[_]: Fx: Log](): F[Count] =\n  counter.currentCount() // F[Count]\n    .log(count => info(s"Current count: $count")) // F[Count]\n'})})]}),(0,o.jsxs)(i.A,{value:"no-syntax",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'val fa: F[A] = ...\nLog[F].log(fa)(a => debug(s"Some meesage: $a")) // F[A]\nLog[F].log(fa)(a => info(s"Some meesage: $a"))  // F[A]\nLog[F].log(fa)(a => warn(s"Some meesage: $a"))  // F[A]\nLog[F].log(fa)(a => error(s"Some meesage: $a")) // F[A]\n'})}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import effectie.core._\nimport loggerf.core._\nimport loggerf.syntax.all._\n\ndef count[F[_]: Fx: Log](): F[Count] =\n  Log[F].log(counter.currentCount())(count => info(s"Current count: $count"))\n'})})]})]}),"\n",(0,o.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nimport loggerf.core._\nimport loggerf.syntax.all._\nimport loggerf.logger._\n\ndef hello[F[_]: Functor: Fx: Log](name: String): F[Unit] =\n  s"Hello $name".logS(debug).map(println(_))\n \nobject MyApp extends IOApp {\n\n  implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog("MyApp")\n\n  import effectie.instances.ce2.fx._\n  \n  \n  def run(args: List[String]): IO[ExitCode] = for {\n    _ <- hello[IO]("World")\n    _ <- hello[IO]("Kevin")\n  } yield ExitCode.Success\n}\n\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"23:34:25.021 [ioapp-compute-1] DEBUG MyApp - Hello World\nHello World\n23:34:25.022 [ioapp-compute-1] DEBUG MyApp - Hello Kevin\nHello Kevin\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'trait Named[A] {\n  def name(a: A): String\n}\n\nobject Named {\n  def apply[A: Named]: Named[A] = implicitly[Named[A]]\n}\n\nfinal case class GivenName(givenName: String) extends AnyVal\nfinal case class Surname(surname: String) extends AnyVal\n\nfinal case class Person(givenName: GivenName, surname: Surname)\nobject Person {\n  implicit val namedPerson: Named[Person] =\n    person => s"${person.givenName.givenName} ${person.surname.surname}"\n}\n\nimport cats._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nimport loggerf.core._\nimport loggerf.syntax.all._\nimport loggerf.logger._\n\ntrait Greeting[F[_]] {\n  def greet[A: Named](a: A): F[String]\n}\n\nobject Greeting {\n  def apply[F[_] : Greeting]: Greeting[F] = implicitly[Greeting[F]]\n\n  implicit def hello[F[_]: Fx: Monad: Log]: Greeting[F] =\n    new Greeting[F] {\n      def greet[A: Named](a: A): F[String] = for {\n        name     <- effectOf(Named[A].name(a)).log(x => info(s"The name is $x"))\n        greeting <- pureOf(s"Hello $name").log(greet => debug(s"Greeting: $greet"))\n      } yield greeting\n    }\n\n}\n\nobject MyApp extends IOApp {\n\n  implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog("MyApp")\n\n  import effectie.instances.ce2.fx._\n  \n  \n  def run(args: List[String]): IO[ExitCode] = for {\n    greetingMessage <- Greeting[IO].greet(Person(GivenName("Kevin"), Surname("Lee")))\n    _ <- ConsoleFx[IO].putStrLn(greetingMessage)\n  } yield ExitCode.Success\n}\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"23:04:56.272 [ioapp-compute-0] INFO MyApp - The name is Kevin Lee\n23:04:56.273 [ioapp-compute-0] DEBUG MyApp - Greeting: Hello Kevin Lee\nHello Kevin Lee\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"log-foptiona",children:["Log ",(0,o.jsx)(n.code,{children:"F[Option[A]]"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"Log[F].log(\n  F[Option[A]]\n)(\n  ifEmpty: => LogMessage with MaybeIgnorable,\n  toLeveledMessage: A => LogMessage with MaybeIgnorable\n)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["A given ",(0,o.jsx)(n.code,{children:"F[Option[A]]"}),", you can simply log ",(0,o.jsx)(n.code,{children:"Some(A)"})," or ",(0,o.jsx)(n.code,{children:"None"})," with ",(0,o.jsx)(n.code,{children:"log"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"example-2",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nimport loggerf.core._\nimport loggerf.syntax.all._\nimport loggerf.logger._\n\ndef greeting[F[_]: Fx](name: String): F[String] =\n  pureOf(s"Hello $name")\n\ndef hello[F[_]: Monad: Fx: Log](maybeName: Option[String]): F[Unit] =\n  for {\n    name    <- pureOf(maybeName).log(\n                 warn("No name given"),\n                 name => info(s"Name: $name")\n               )\n    message <- name.traverse(greeting[F]).log(ignore, msg => info(s"Message: $msg"))\n    _       <- effectOf(message.foreach(msg => println(msg)))\n  } yield ()\n\n\nimplicit val canLog: CanLog = Slf4JLogger.slf4JCanLog("MyApp- F[Option[A]]")\n// canLog: CanLog = loggerf.logger.Slf4JLogger@1c19e9a\n\nimport effectie.instances.ce2.fx._\n\n\ndef run(): IO[Unit] = for {\n  _ <- hello[IO](none)\n  _ <- hello[IO]("Kevin".some)\n} yield ()\n\nrun().unsafeRunSync()\n// Hello Kevin\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"20:09:43.117 [Thread-31] WARN MyApp- F[Option[A]] - No name given\n20:09:43.133 [Thread-31] INFO MyApp- F[Option[A]] - Name: Kevin\n20:09:43.133 [Thread-31] INFO MyApp- F[Option[A]] - Message: Hello Kevin\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"log-feithera-b",children:["Log ",(0,o.jsx)(n.code,{children:"F[Either[A, B]]"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"Log[F].log(\n  F[Either[A, B]]\n)(\n  leftToMessage: A => LeveledMessage with MaybeIgnorable,\n  rightToMessage: B => LeveledMessage with MaybeIgnorable\n)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["A given ",(0,o.jsx)(n.code,{children:"F[Either[A, B]]"}),", you can simply log ",(0,o.jsx)(n.code,{children:"Left(A)"})," or ",(0,o.jsx)(n.code,{children:"Right(B)"})," with ",(0,o.jsx)(n.code,{children:"log"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"example-3",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nimport loggerf.core._\nimport loggerf.syntax.all._\nimport loggerf.logger._\n\ndef foo[F[_]: Fx](a: Int): F[Int] =\n  pureOf(a * 2)\n\ndef divide[F[_]: Fx: CanHandleError](a: Int, b: Int): F[Either[String, Int]] =\n  effectOf((a / b).asRight[String])\n    .handleNonFatal{ err =>\n      err.getMessage.asLeft[Int]\n    }\n\ndef calculate[F[_]: Monad: Fx: CanHandleError: Log](n: Int): F[Unit] =\n  for {\n    a      <- foo(n).log(\n                n => info(s"n: ${n.toString}")\n              )\n    result <- divide(1000, a).log(\n                err => error(s"Error: $err"),\n                r => info(s"Result: ${r.toString}")\n              )\n    _      <- effectOf(println(result.fold(err => s"Error: $err", r => s"1000 / ${a.toString} = ${r.toString}")))\n  } yield ()\n\n\nimplicit val canLog: CanLog = Slf4JLogger.slf4JCanLog("MyApp - F[Either[A, B]]")\n// canLog: CanLog = loggerf.logger.Slf4JLogger@37f4474\n\nimport effectie.instances.ce2.fx._\n\n\ndef run(): IO[Unit] = for {\n  _ <- calculate[IO](5)\n  _ <- calculate[IO](0)\n} yield ()\n\nrun().unsafeRunSync()\n// 1000 / 10 = 100\n// Error: / by zero\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"20:20:05.588 [Thread-47] INFO MyApp - F[Either[A, B]] - n: 10\n20:20:05.593 [Thread-47] INFO MyApp - F[Either[A, B]] - Result: 100\n20:20:05.595 [Thread-47] INFO MyApp - F[Either[A, B]] - n: 0\n20:20:05.605 [Thread-47] ERROR MyApp - F[Either[A, B]] - Error: / by zero\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"log-optiontf-a",children:["Log ",(0,o.jsx)(n.code,{children:"OptionT[F, A]"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"Log[F].log(\n  OptionT[F, A]\n)(\n  ifEmpty: => LogMessage with MaybeIgnorable,\n  toLeveledMessage: A => LogMessage with MaybeIgnorable\n)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["A given ",(0,o.jsx)(n.code,{children:"OptionT[F, A]"}),", you can simply log it with ",(0,o.jsx)(n.code,{children:"log"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"example-4",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.data._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nimport loggerf.core._\nimport loggerf.syntax.all._\nimport loggerf.logger._\n\ndef greeting[F[_]: Fx](name: String): F[String] =\n  pureOf(s"Hello $name")\n\ndef hello[F[_]: Monad: Fx: Log](maybeName: Option[String]): F[Unit] =\n  (for {\n    name    <- OptionT(pureOf(maybeName))\n                 .log(\n                   warn("No name given"),\n                   name => info(s"Name: $name")\n                 )\n    message <- OptionT.liftF(greeting[F](name))\n                 .log(ignore, msg => info(s"Message: $msg"))\n  } yield message)\n    .foreachF(msg => effectOf(println(msg)))\n\n\nimplicit val canLog: CanLog = Slf4JLogger.slf4JCanLog("MyApp- OptionT[F, A]")\n// canLog: CanLog = loggerf.logger.Slf4JLogger@4ed8693a\n\nimport effectie.instances.ce2.fx._\n\n\ndef run(): IO[Unit] = for {\n  _ <- hello[IO](none)\n  _ <- hello[IO]("Kevin".some)\n} yield ()\n\nrun().unsafeRunSync()\n// Hello Kevin\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"21:49:30.118 [Thread-58] WARN MyApp- OptionT[F, A] - No name given\n21:49:30.119 [Thread-58] INFO MyApp- OptionT[F, A] - Name: Kevin\n21:49:30.121 [Thread-58] INFO MyApp- OptionT[F, A] - Message: Hello Kevin\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"log-eithertf-a-b",children:["Log ",(0,o.jsx)(n.code,{children:"EitherT[F, A, B]"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"Log[F].log(\n  EitherT[F, A, B]\n)(\n  leftToMessage: A => LeveledMessage with MaybeIgnorable,\n  rightToMessage: B => LeveledMessage with MaybeIgnorable\n)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["A given ",(0,o.jsx)(n.code,{children:"Either[F, A, B]"}),", you can simply log it with ",(0,o.jsx)(n.code,{children:"log"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"example-5",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.data._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nimport loggerf.core._\nimport loggerf.syntax.all._\nimport loggerf.logger._\n\ndef foo[F[_]: Fx](a: Int): F[Int] =\n  pureOf(a * 2)\n\ndef divide[F[_]: Fx: CanHandleError](a: Int, b: Int): F[Either[String, Int]] =\n  effectOf((a / b).asRight[String])\n    .handleNonFatal{ err =>\n      err.getMessage.asLeft[Int]\n    }\n\ndef calculate[F[_]: Monad: Fx: CanHandleError: Log](n: Int): F[Unit] =\n  (for {\n    a      <- EitherT.liftF[F, String, Int](foo(n))\n                .log(\n                  ignoreA,\n                  n => info(s"n: ${n.toString}")\n                )\n    result <- EitherT(divide(1000, a))\n                .log(\n                  err => error(s"Error: $err"),\n                  r => info(s"Result: ${r.toString}")\n                )\n  } yield result)\n    .foldF(\n      err => effectOf(println(s"Error: $err")),\n      r => effectOf(println(s"1000 / ${n.toString} = ${r.toString}"))\n    )\n\n\nimplicit val canLog: CanLog = Slf4JLogger.slf4JCanLog("MyApp - EitherT[F, A, B]")\n// canLog: CanLog = loggerf.logger.Slf4JLogger@5ca49aae\n\nimport effectie.instances.ce2.fx._\n\n\ndef run(): IO[Unit] = for {\n  _ <- calculate[IO](5)\n  _ <- calculate[IO](0)\n} yield ()\n\nrun().unsafeRunSync()\n// 1000 / 5 = 100\n// Error: / by zero\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"22:14:24.272 [Thread-66] INFO MyApp - EitherT[F, A, B] - n: 10\n22:14:24.275 [Thread-66] INFO MyApp - EitherT[F, A, B] - Result: 100\n22:14:24.275 [Thread-66] INFO MyApp - EitherT[F, A, B] - n: 0\n22:14:24.279 [Thread-66] ERROR MyApp - EitherT[F, A, B] - Error: / by zero\n"})})]})}function p(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(f,{...e})}):f(e)}},9365:(e,n,r)=>{r.d(n,{A:()=>t});r(6540);var a=r(4164);const o={tabItem:"tabItem_Ymn6"};var l=r(4848);function t({children:e,hidden:n,className:r}){return(0,l.jsx)("div",{role:"tabpanel",className:(0,a.A)(o.tabItem,r),hidden:n,children:e})}}}]);