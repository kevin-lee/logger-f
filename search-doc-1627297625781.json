[{"title":"For Cats Effect","type":0,"sectionRef":"#","url":"docs/cats-effect/cats-effect","content":"","keywords":""},{"title":"LoggerF for Cats Effect (WIP)","type":1,"pageTitle":"For Cats Effect","url":"docs/cats-effect/cats-effect#loggerf-for-cats-effect-wip","content":""},{"title":"Log","type":1,"pageTitle":"For Cats Effect","url":"docs/cats-effect/cats-effect#log","content":""},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/","content":"","keywords":""},{"title":" LoggerF - Logger for F[_]","type":1,"pageTitle":"Getting Started","url":"docs/#loggerf---logger-for-f_","content":"LoggerF is a tool for logging tagless final with an effect library. LoggerF requires Effectie to construct F[_]. All the example code in this doc site uses Effectie so if you're not familiar with it, please check out Effectie website. Why LoggerF? Why not just log with map or flatMap? Please read \"Why?\" section. "},{"title":"Getting Started","type":1,"pageTitle":"Getting Started","url":"docs/#getting-started","content":""},{"title":"Get LoggerF For Cats Effect","type":1,"pageTitle":"Getting Started","url":"docs/#get-loggerf-for-cats-effect","content":"With SLF4J# In build.sbt, Cats Effect 3Cats Effect 2 libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-cats-effect\" % \"1.13.0\", \"io.kevinlee\" %% \"logger-f-slf4j\" % \"1.13.0\" ) Copy With Log4j# Cats Effect 3Cats Effect 2 libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-cats-effect\" % \"1.13.0\", \"io.kevinlee\" %% \"logger-f-log4j\" % \"1.13.0\" ) Copy With Log4s# Cats Effect 3Cats Effect 2 libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-cats-effect\" % \"1.13.0\", \"io.kevinlee\" %% \"logger-f-log4s\" % \"1.13.0\" ) Copy With sbt Logging Util# You probably need logger-f for sbt plugin development. Cats Effect 3Cats Effect 2 libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-cats-effect\" % \"1.13.0\", \"io.kevinlee\" %% \"logger-f-sbt-logging\" % \"1.13.0\" ) Copy "},{"title":"Get LoggerF For Monix","type":1,"pageTitle":"Getting Started","url":"docs/#get-loggerf-for-monix","content":"With SLF4J# In build.sbt, libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-monix\" % \"1.13.0\", \"io.kevinlee\" %% \"logger-f-slf4j\" % \"1.13.0\" ) Copy With Log4j# libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-monix\" % \"1.13.0\", \"io.kevinlee\" %% \"logger-f-log4j\" % \"1.13.0\" ) Copy With Log4s# libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-monix\" % \"1.13.0\", \"io.kevinlee\" %% \"logger-f-log4s\" % \"1.13.0\" ) Copy With sbt Logging Util# You probably need logger-f for sbt plugin development. libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-monix\" % \"1.13.0\", \"io.kevinlee\" %% \"logger-f-sbt-logging\" % \"1.13.0\" ) Copy "},{"title":"Get LoggerF For Scalaz Effect","type":1,"pageTitle":"Getting Started","url":"docs/#get-loggerf-for-scalaz-effect","content":"With SLF4J# In build.sbt, libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-scalaz-effect\" % \"1.13.0\", \"io.kevinlee\" %% \"logger-f-slf4j\" % \"1.13.0\" ) Copy With Log4j# In build.sbt, libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-scalaz-effect\" % \"1.13.0\", \"io.kevinlee\" %% \"logger-f-log4j\" % \"1.13.0\" ) Copy With Log4s# In build.sbt, libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-scalaz-effect\" % \"1.13.0\", \"io.kevinlee\" %% \"logger-f-log4s\" % \"1.13.0\" ) Copy With sbt Logging Util# In build.sbt, libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-scalaz-effect\" % \"1.13.0\", \"io.kevinlee\" %% \"logger-f-sbt-logging\" % \"1.13.0\" ) Copy "},{"title":"Why","type":1,"pageTitle":"Getting Started","url":"docs/#why","content":"If you code tagless final and use some effect library like Cats Effect or Monix or Scalaz Effect, you may have inconvenience in logging. What inconvenience? I can just log with flatMap like. for { a <- foo(n) // F[A] _ <- effectOf(logger.debug(s\"blah blah $a\")) b <- bar(a) // F[A] } yield b Copy That's true but what happens if you want to use Option or Either? If you use them with tagless final, you may get the result you want. e.g.) import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ def foo[F[_] : Fx : Monad](n: Int): F[Option[Int]] = for { a <- effectOf(n.some) b <- effectOf(none[Int]) c <- effectOf(123.some) } yield c foo[IO](1).unsafeRunSync() // You expect None here!!! // res1: Option[Int] = Some(value = 123) Copy You expect None for the result due to effectOf(none[Int]) yet you get Some(123) instead. That's because b is Option[Int] not Int. The same issue exists for F[Either[A, B]] as well. So you need to use OptionT for F[Option[A]] and EitherT for F[Either[A, B]]. Let's write it again with OptionT. import cats._ import cats.data._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ def foo[F[_] : Fx : Monad](n: Int): F[Option[Int]] = (for { a <- OptionT(effectOf(n.some)) b <- OptionT(effectOf(none[Int])) c <- OptionT(effectOf(123.some)) } yield c).value foo[IO](1).unsafeRunSync() // You expect None here. // res3: Option[Int] = None Copy The problem's gone! Now each flatMap handles only Some case and that's what you want. However, because of that, it's hard to log None case. LoggerF can solve this issue for you. import cats._ import cats.data._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ // or Slf4JLogger.slf4JLogger[MyClass] implicit val logger: CanLog = Slf4JLogger.slf4JCanLog(\"MyLogger\") // logger: CanLog = loggerf.logger.Slf4JLogger@766fb6 def foo[F[_] : Fx : Monad : Log](n: Int): F[Option[Int]] = (for { a <- log(OptionT(effectOf(n.some)))( ifEmpty = error(\"a is empty\"), a => debug(s\"a is $a\") ) b <- log(OptionT(effectOf(none[Int])))( error(\"b is empty\"), b => debug(s\"b is $b\") ) c <- log(OptionT(effectOf(123.some)))( warn(\"c is empty\"), c => debug(s\"c is $c\") ) } yield c).value foo[IO](1).unsafeRunSync() // You expect None here. // res5: Option[Int] = None Copy With logs like 00:17:33.983 [main] DEBUG MyLogger - a is 1 00:17:33.995 [main] ERROR MyLogger - b is empty Copy  Another example with EitherT, import cats._ import cats.data._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ // or Slf4JLogger.slf4JLogger[MyClass] implicit val logger: CanLog = Slf4JLogger.slf4JCanLog(\"MyLogger\") // logger: CanLog = loggerf.logger.Slf4JLogger@f336f2e def foo[F[_] : Fx : Monad : Log](n: Int): F[Either[String, Int]] = (for { a <- log(EitherT(effectOf(n.asRight[String])))( err => error(s\"Error: $err\"), a => debug(s\"a is $a\") ) b <- log(EitherT(effectOf(\"Some Error\".asLeft[Int])))( err => error(s\"Error: $err\"), b => debug(s\"b is $b\") ) c <- log(EitherT(effectOf(123.asRight[String])))( err => warn(s\"Error: $err\"), c => debug(s\"c is $c\") ) } yield c).value foo[IO](1).unsafeRunSync() // You expect Left(\"Some Error\") here. // res7: Either[String, Int] = Left(value = \"Some Error\") Copy With logs like 00:40:48.663 [main] DEBUG MyLogger - a is 1 00:40:48.667 [main] ERROR MyLogger - Error: Some Error Copy "},{"title":"Usage","type":1,"pageTitle":"Getting Started","url":"docs/#usage","content":"Pleae check out LoggerF for Cats EffectLoggerF for MonixLoggerF for Scalaz Effect "},{"title":"Log - Monix","type":0,"sectionRef":"#","url":"docs/monix/log","content":"","keywords":""},{"title":"Log - Monix (WIP)","type":1,"pageTitle":"Log - Monix","url":"docs/monix/log#log---monix-wip","content":"Log is a typeclass to log F[A], F[Option[A]], F[Either[A, B]], OptionT[F, A] and EitherT[F, A, B]. It requires Fx from Effectie and Monad from Cats. "},{"title":"Log F[A]","type":1,"pageTitle":"Log - Monix","url":"docs/monix/log#log-fa","content":"Log[F].log(F[A])(A => String) Copy "},{"title":"Example","type":1,"pageTitle":"Log - Monix","url":"docs/monix/log#example","content":"trait Named[A] { def name(a: A): String } object Named { def apply[A: Named]: Named[A] = implicitly[Named[A]] } final case class GivenName(givenName: String) extends AnyVal final case class Surname(surname: String) extends AnyVal final case class Person(givenName: GivenName, surname: Surname) object Person { implicit val namedPerson: Named[Person] = person => s\"${person.givenName.givenName} ${person.surname.surname}\" } import cats._ import cats.syntax.all._ import cats.effect.ExitCode import effectie.monix.{ConsoleEffect, Fx} import effectie.monix.Effectful._ import loggerf.logger._ import loggerf.monix._ import loggerf.syntax._ import monix.eval.Task import monix.eval.TaskApp trait Greeting[F[_]] { def greet[A: Named](a: A): F[String] } object Greeting { def apply[F[_]: Greeting]: Greeting[F] = implicitly[Greeting[F]] implicit def hello[F[_]: Fx: Monad: Log]: Greeting[F] = new Greeting[F] { def greet[A: Named](a: A): F[String] = for { name <- log(effectOf(Named[A].name(a)))(x => info(s\"The name is $x\")) greeting <- pureOf(s\"Hello $name\") } yield greeting } } object TaskMainApp extends TaskApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(\"MyApp\") def run(args: List[String]): Task[ExitCode] = for { greetingMessage <- Greeting[Task].greet( Person(GivenName(\"Kevin\"), Surname(\"Lee\")) ) _ <- ConsoleEffect[Task].putStrLn(greetingMessage) } yield ExitCode.Success } Copy 19:57:04.076 [scala-execution-context-global-21] INFO MyApp - The name is Kevin Lee Hello Kevin Lee Copy "},{"title":"Log F[Option[A]]","type":1,"pageTitle":"Log - Monix","url":"docs/monix/log#log-foptiona","content":""},{"title":"Log OptionT[F, A]","type":1,"pageTitle":"Log - Monix","url":"docs/monix/log#log-optiontf-a","content":""},{"title":"Log F[Either[A, B]]","type":1,"pageTitle":"Log - Monix","url":"docs/monix/log#log-feithera-b","content":""},{"title":"Log EitherT[F, A, B]","type":1,"pageTitle":"Log - Monix","url":"docs/monix/log#log-eithertf-a-b","content":""},{"title":"Log - Cats","type":0,"sectionRef":"#","url":"docs/cats-effect/log","content":"","keywords":""},{"title":"Log - Cats (WIP)","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log---cats-wip","content":"Log is a typeclass to log F[A], F[Option[A]], F[Either[A, B]], OptionT[F, A] and EitherT[F, A, B]. It requires Fx from Effectie and Monad from Cats. "},{"title":"Log F[A]","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-fa","content":"Log[F].log(F[A])(A => String) Copy "},{"title":"Example","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#example","content":"trait Named[A] { def name(a: A): String } object Named { def apply[A: Named]: Named[A] = implicitly[Named[A]] } final case class GivenName(givenName: String) extends AnyVal final case class Surname(surname: String) extends AnyVal final case class Person(givenName: GivenName, surname: Surname) object Person { implicit val namedPerson: Named[Person] = person => s\"${person.givenName.givenName} ${person.surname.surname}\" } import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats.Fx import effectie.cats.ConsoleEffect import effectie.cats.Effectful._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ trait Greeting[F[_]] { def greet[A: Named](a: A): F[String] } object Greeting { def apply[F[_] : Greeting]: Greeting[F] = implicitly[Greeting[F]] implicit def hello[F[_]: Fx: Monad: Log]: Greeting[F] = new Greeting[F] { def greet[A: Named](a: A): F[String] = for { name <- log(effectOf(Named[A].name(a)))(x => info(s\"The name is $x\")) greeting <- pureOf(s\"Hello $name\") } yield greeting } } object MyApp extends IOApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(\"MyApp\") def run(args: List[String]): IO[ExitCode] = for { greetingMessage <- Greeting[IO].greet(Person(GivenName(\"Kevin\"), Surname(\"Lee\"))) _ <- ConsoleEffect[IO].putStrLn(greetingMessage) } yield ExitCode.Success } Copy 21:02:15.323 [ioapp-compute-0] INFO MyApp - The name is Kevin Lee Hello Kevin Lee Copy "},{"title":"Log F[Option[A]]","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-foptiona","content":""},{"title":"Log OptionT[F, A]","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-optiontf-a","content":""},{"title":"Log F[Either[A, B]]","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-feithera-b","content":""},{"title":"Log EitherT[F, A, B]","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-eithertf-a-b","content":""},{"title":"For Monix","type":0,"sectionRef":"#","url":"docs/monix/monix","content":"","keywords":""},{"title":"LoggerF for Monix (WIP)","type":1,"pageTitle":"For Monix","url":"docs/monix/monix#loggerf-for-monix-wip","content":""},{"title":"Log","type":1,"pageTitle":"For Monix","url":"docs/monix/monix#log","content":""},{"title":"For Scalaz Effect","type":0,"sectionRef":"#","url":"docs/scalaz-effect/scalaz-effect","content":"","keywords":""},{"title":"LoggerF for Scalaz Effect (WIP)","type":1,"pageTitle":"For Scalaz Effect","url":"docs/scalaz-effect/scalaz-effect#loggerf-for-scalaz-effect-wip","content":""},{"title":"Log","type":1,"pageTitle":"For Scalaz Effect","url":"docs/scalaz-effect/scalaz-effect#log","content":""},{"title":"Log - Scalaz","type":0,"sectionRef":"#","url":"docs/scalaz-effect/log","content":"","keywords":""},{"title":"Log - Scalaz (WIP)","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log---scalaz-wip","content":"Log is a typeclass to log F[A], F[Option[A]], F[A \\/ B], OptionT[F, A] and EitherT[F, A, B]. It requires Fx from Effectie and Monad from Scalaz. "},{"title":"Log F[A]","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-fa","content":"Log[F].log(F[A])(A => String) Copy "},{"title":"Example","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#example","content":"trait Named[A] { def name(a: A): String } object Named { def apply[A: Named]: Named[A] = implicitly[Named[A]] } final case class GivenName(givenName: String) extends AnyVal final case class Surname(surname: String) extends AnyVal final case class Person(givenName: GivenName, surname: Surname) object Person { implicit val namedPerson: Named[Person] = person => s\"${person.givenName.givenName} ${person.surname.surname}\" } import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz.Fx import effectie.scalaz.ConsoleEffect import effectie.scalaz.Effectful._ import loggerf.logger._ import loggerf.scalaz._ import loggerf.syntax._ trait Greeting[F[_]] { def greet[A: Named](a: A): F[String] } object Greeting { def apply[F[_] : Greeting]: Greeting[F] = implicitly[Greeting[F]] implicit def hello[F[_]: Fx: Monad: Log]: Greeting[F] = new Greeting[F] { def greet[A: Named](a: A): F[String] = for { name <- log(effectOf(Named[A].name(a)))(x => info(s\"The name is $x\")) greeting <- pureOf(s\"Hello $name\") } yield greeting } } object MyApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(\"MyApp\") def run(args: List[String]): IO[Unit] = for { greetingMessage <- Greeting[IO].greet(Person(GivenName(\"Kevin\"), Surname(\"Lee\"))) _ <- ConsoleEffect[IO].putStrLn(greetingMessage) } yield () def main(args: Array[String]): Unit = run(args.toList).unsafePerformIO() } Copy 21:02:15.323 [ioapp-compute-0] INFO MyApp - The name is Kevin Lee Hello Kevin Lee Copy "},{"title":"Log F[Option[A]]","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-foptiona","content":""},{"title":"Log OptionT[F, A]","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-optiontf-a","content":""},{"title":"Log F[A \\/ B]","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-fa--b","content":""},{"title":"Log EitherT[F, A, B]","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-eithertf-a-b","content":""}]